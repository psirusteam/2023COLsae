# Día 4 - Sesión 3- Estimación de uso de métodos de planificación familiar empleando modelos de unidad

```{r setup, include=FALSE, message=FALSE, error=FALSE, warning=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  message = FALSE,
  warning = FALSE,
  cache = TRUE
)
library(printr)
library(kableExtra)
library(tidyverse)
library(magrittr)
library(rstan)
library(rstantools)
library(rstanarm)
tba <- function(dat, cap = NA){
  kable(dat,
      format = "html", digits =  4,
      caption = cap) %>% 
     kable_styling(bootstrap_options = "striped", full_width = F)%>%
         kable_classic(full_width = F, html_font = "Arial Narrow")
}
```

Para los gobiernos y las organizaciones internacionales es muy importante conocer las condiciones de calidad de vida de las personas en lo que incluye la salud, por lo cual, evaluar la capacidad que estas tienen para cubrir sus necesidades de planificación familiar y de acceso a diferentes métodos modernos de planificicación; es fundamental para el diseño y formulación de políticas públicas. Por esta razón, el realizar mapas de uso de métodos de planificación familiar mediante metodologías adecuadas que permitan llegar a estimaciones precisas, se convierte en una herramienta preciada para identificar no solamente las áreas geográficas más vulnerables en términos salud sexual y reproductiva (departamentos, regiones, municipios, provincias, comunas o la división geográfica característica de cada país) sino también la situación de grupos o segmentos poblacionales de interés.



## Definiciones de los indicadores de interés.

-   Indicador D6 métodos de planificación

    Este indicador, alude a la tasa de prevalencia de uso de métodos anticonceptivos de mujeres sin importar el tipo de método ya sea moderno, tradicional o folclórico, la cual se compone por mujeres en edad fértil (entre 15 y 49 años) y sexualmente activas
    
-   Indicador D6m métodos modernos de planificación

    Este indicador, corresponde a la tasa de prevalencia que hace referencia al uso de métodos anticonceptivos de tipo moderno. la cual se compone por mujeres por mujeres en edad fértil (entre 15 y 49 años), sexualmente activas que hacen uso de algún método de tipo moderno.
    
-   Indicador NI necesidades insatisfechas

    La definición de este indicador, se entiende como la tasa de prevalencia de mujeres en edad de procrear que por algún motivo no son capaces de cubrir sus necesidades de planificación familiar con algún método anticonceptivo (moderno o tradicional). Esta se compone, por mujeres en edad fértil (entre 15 a 49 años), sexualmente activas y/o unidas que afirma no ser capaces de cubrir sus necesidades de planificación familiar con algún método anticonceptivo (tradicional y/o modernos) 
    
-   D7 (junto con necesidades insatisfechas)
    
    Este indicador, hace referencia a la proporción de mujeres en edad de procrear (15 a 49 años), sexualmente activas y/o unidas que han decidido por voluntad propia no tener hijos (adicionales) o posponer su siguiente hijo y para ello se encuentran utilizando métodos anticonceptivos modernos. 

## Estandarización de la encuesta

Se presentan las variables provenientes de la Encuesta Nacional de Salud Materno Infantil (ENSMI), que fueron empleadas para la construcción de los datos que son utilizadas en este estudio e incluidas en el ajuste del modelo.

### Tipo de vivienda {-}

  1. Las opciones 3 y 4 de la encuesta se colapsaron en la categoría “3. Tipo cuarto”, categoría asociada a la opción de respuesta 3 del censo.

  2. Las opciones 4 y 5 del censo se unieron en la categoría “4. Vivienda étnica”, mientras que la opción 5 de la encuesta se recodificó de la misma manera.

  3. La opción 6 del censo y de la encuesta se recodificaron en la categoría unificada “Otro (contenedor, carpa, embarcación, vagón, cueva, refugio natural, etc.)”.


```{r echo=FALSE, out.width = "800px", out.height="200px",fig.align='center'}
knitr::include_graphics("0Recursos/Tipo de vivienda.png")
```

### ¿Cuál es el material que predomina en las paredes exteriores de la vivienda en la que usted reside? {-}

  1.    En el censo se colapsaron las opciones de respuesta 1, 2 y 3, al igual que las opciones 1 y 2 de la encuesta en la categoría unificada “1. Ladrillo, bloque, material prefabricado, piedra, madera pulida, concreto vaciado”
  
  2.    En la encuesta se unieron las opciones de respuesta 3 y 4 en la categoría unificada “2. Adobe, tapia pisada o Bahareque”; en el censo se recodificó la opción 5 por esta categoría. 
  
  3.    La opción de respuesta 6 del censo y 5 de la encuesta se recodificaron en la categoría “3. Madera burda, tabla, tablón”
  
  4.    La opción 5 de la encuesta se recodificó en la categoría “4. Guadua”
  
  5.    La opción de respuesta 7, tanto del censo como de la encuesta, se recodificó en la categoría “5. Caña, esterilla, otro tipo de material vegetal”
  
  6.    La opción de respuesta 8, tanto del censo como de la encuesta, se recodificó en la categoría “6. Zinc, tela, cartón, latas, desechos, plástico”
  
  7.    La opción de respuesta 9, tanto del censo como de la encuesta, se recodificó en la categoría “7. Sin paredes”

```{r echo=FALSE, out.width = "800px", out.height="300px",fig.align='center'}
knitr::include_graphics("0Recursos/Material paredes.png")
```


### ¿Cuál es el material que predomina en los pisos de la vivienda que usted reside? {-}
  1.    En la encuesta se unieron las opciones de respuesta 5 y 6 en la categoría unificada “1. Mármol, parqué, madera pulida y lacada”
  
  2.    La opción 4 de la encuesta se recodificó en la categoría “2. Baldosa, vinilo, tableta, ladrillo, laminado”
  
  3.    La opción 7 de la encuesta se recodificó en la categoría “3. Alfombra”
  
  4.    La opción 2 de la encuesta se recodificó en la categoría “4. Cemento, gravilla”
  
  5.    La opción 3 de la encuesta se recodificó en la categoría “5. Madera burda, tabla, tablón, otro vegetal”
  
  6.    La opción 1 de la encuesta se recodificó en la categoría “6. Tierra, arena, barro”

```{r echo=FALSE, out.width = "800px", out.height="250px",fig.align='center'}
knitr::include_graphics("0Recursos/Material piso.png")
```


### ¿De dónde obtiene principalmente su hogar el agua para preparar los alimentos? {-}

  1.    En la encuesta se unieron las opciones de respuesta 1 y 2 en la categoría unificada “1. ¿Acueducto público?”
  
  2.    En el censo se unieron las opciones de respuesta 2 y 3 en la categoría unificada “2. ¿Acueducto veredal o red de distribución comunitaria?”
  
  3.    La opción de respuesta 4 del censo y 3 de la encuesta se recodificaron en la categoría “3. ¿Pozo con bomba?”
  
  4.    La opción de respuesta 5 del censo y 4 de la encuesta se recodificaron en la categoría “4. ¿Pozo sin bomba, aljibe, jaguey o barreno?”
  
  5.    La opción de respuesta 6 del censo y 5 de la encuesta se recodificaron en la categoría “5. ¿Agua lluvia?”
  
  6.    La opción de respuesta 7 del censo y 6 de la encuesta se recodificaron en la categoría “6. ¿Río, quebrada, manantial, nacimiento?”
  
  7.    La opción de respuesta 8 del censo y 7 de la encuesta se recodificaron en la categoría “7. ¿Pila pública?”
  
  8.    La opción de respuesta 9 del censo y 8 de la encuesta se recodificaron en la categoría “8. ¿Carrotanque?”
  
  9.    La opción de respuesta 10 del censo y 9 de la encuesta se recodificaron en la categoría “9. ¿Aguatero?”
  
  10.   La opción de respuesta 11 del censo y 10 de la encuesta se recodificaron en la categoría “10. ¿Agua embotellada o en bolsa?”
  
  11.   En el censo se unieron las opciones de respuesta 11 y 12 en la categoría unificada “11. NS/NR”
  
```{r echo=FALSE, out.width = "800px", out.height="350px",fig.align='center'}
knitr::include_graphics("0Recursos/Agua_alimento.png")
```


### ¿Cuál es el nivel educativo más alto alcanzado por ... y el último año o grado aprobado en ese nivel? {-}
  1.    La opción de respuesta 10 del censo se recodificó en la categoría “1. Ninguno”.
  
  2.    La opción de respuesta 1 del censo se recodificó en la categoría “2. Preescolar”.
  
  3.    La opción de respuesta 2 del censo se recodificó en la categoría “3. Básica primaria (1o - 5o)”
  
  4.    La opción de respuesta 3 del censo se recodificó en la categoría “4. Básica secundaria (6o - 9o)”
  
  5.    En el censo se unieron las opciones de respuesta 4, 5 y 6 en la categoría unificada “5. Media (10o - 13o)”
  
  6.    En el censo se unieron las opciones de respuesta 7, 8 y 9 en la categoría unificada “Superior o universitaria”
  
  7.    Las opciones de respuesta 99 y 9 del censo y la encuesta, respectivamente, se recodificaron en la categoría “No sabe, no informa”

```{r echo=FALSE, out.width = "800px", out.height="250px",fig.align='center'}
knitr::include_graphics("0Recursos/Nivel_educativo.png")
```

### ¿En qué actividad ocupó ... la mayor parte del tiempo la semana pasada? {-}
  1.    En el censo se unieron las opciones de respuesta 1, 2 y 3 en la categoría unificada “1. Trabajando”
  
  2.    La opción de respuesta 4 en el censo se recodificó en la categoría “2. Buscando trabajo”
  
  3.    La opción de respuesta 6 en el censo se recodificó en la categoría “3. Estudiando”
  
  4.    La opción de respuesta 7 del censo se recodificó en la categoría “4. Oficios del hogar”
  
  5.    La opción de respuesta 8 del censo se recodificó en la categoría “5. Incapacitado permanente para trabajar”
  
  6.    En el censo se unieron las opciones de respuesta 5 y 9 en la categoría unificada “6. Otra actividad”
  
  7.    La opción de respuesta 0 del censo se recodificó en la categoría “7. No informa, No aplica”
  
```{r echo=FALSE, out.width = "800px", out.height="350px",fig.align='center'}
knitr::include_graphics("0Recursos/Actividad_semana_anterior.png")
```


### ¿Actualmente el estado civil de … es: {-}

  1.    En la encuesta, se unieron las opciones de respuesta 1 y 2 en la categoría unificada “1. Unión libre”
  2.    En la encuesta, la opción de respuesta 3 se recodificó en la categoría “2. Casado(a)”
  3.    En el censo se unieron las opciones de respuesta 3, 4 y 5 en la categoría unificada “3. Está separado (a) o divorciado (a)”; en la encuesta, se recodificó la opción de respuesta 4 en esta categoría unificada.
  4.    Las opciones de respuesta 6 y 5 del censo y la encuesta, respectivamente, se recodificaron en la categoría unificada “4. Está viudo (a)”
  5.    Las opciones de respuesta 7 y 6 del censo y la encuesta, respectivamente, se recodificaron en la categoría unificada “Está soltero (a)”
  6.    Las demás opciones del censo y la encuesta se clasificaron en la categoría “6. No Informa, No Aplica”

```{r echo=FALSE, out.width = "800px", out.height="200px",fig.align='center'}
knitr::include_graphics("0Recursos/Estado_civil.png")
```

### Indicadores 

Empleando la variable V313 se creó una variable dicotómica que permite identificar las mujeres que indican estar utilizando actualmente algún método anticonceptivo (folclóricos, tradicionales y/o modernos).  

```{r echo=FALSE, out.width = "700px", out.height="100px",fig.align='center'}
knitr::include_graphics("0Recursos/usametodo.png")
```

De forma similar se define la variable dummy para métodos de planificación familiar modernos (D6m)

```{r echo=FALSE, out.width = "700px", out.height="100px",fig.align='center'}
knitr::include_graphics("0Recursos/usamoderno.png")
```

Para la estimación de las mujeres con necesidades de planificación familiar insatisfechas (NI) se consideran aquellas que, deseando utilizar algún método de planificación familiar, no tienen acceso o no los utilizan por algún motivo. En la estimación de este indicador no se consideran las mujeres sexualmente activas ya que a nivel censal no son posibles de identificar. Por tal motivo, se define S'⊂S el subconjunto de mujeres que declaran tener una unión consensual o estar casadas.

```{r echo=FALSE, out.width = "700px", out.height="200px",fig.align='center'}
knitr::include_graphics("0Recursos/Necesidades_insatisfechas.png")
```
`

El indicador de necesidades satisfechas de planificación por métodos modernos (D7) no se crea a partir de las variables originales de la encuesta, ya que es una razón entre los otros tres indicadores creados así:


$$
D7 = \frac{D6m}{D6 +NI}
$$


### 	Variables para el diseño muestral

-   Unidad primaria de muestreo - UPM
    
    Para la definifición de esta variable, se emplea la variable original de la encuesta “hv021”. 
    
-   Estrato

    Para la definifición de esta variable, se emplea la variable original de la encuesta “hv023”.
    
-   Factor ponderador - fexp

    El factor de expansión estaconsiganado en la variable  “v005”. Apartir de este de define el _factor ponderador_ el cual requiere que al valor de la variable se le multiplique una constante  la cual hace referencia al número de mujeres en edad fértil (15 a 49 años); y, a ese valor se divide por la suma de la variable(V005).  

La tabla resultante se muestra en la siguiente tabla. 

```{r}
encuesta_mrp <- readRDS("UNFPA/D6/encuesta_mrp.rds") %>% 
  rename(dam2 = mpio)
tba(encuesta_mrp %>% head(10))
```


## Censos de población y vivienda

Es necesario definir las variables del país con los que se desea trabajar. De acuerdo a esto, como primer paso se debe tener acceso al censo del país, para ello puede acceder desde el siguiente enlace <https://redatam.org/en/microdata> en el cual dispondrá de un archivo *.zip* con los microdatos del país. Ahora bien, para leer el conjunto de datos, es necesario emplear la función redatam.open de la librería `redatam`, la cual depende directamente del diccionario censal del software REDATAM, este es un archivo con extensión dicx y que debe encontrarse en la carpeta sobre los datos que se están leyendo. Así, es como se crea un objeto dentro de `R` que hace la respectiva unión del diccionario con los microdatos de la base de datos censal. La siguiente sintaxis muestra la lectura del diccionario en `R` y los cálculos iniciales

 

```{r, eval=FALSE}
library(redatam)
colombia <-  redatam.open( "UNFPA/D6/Data/cpv2018col-cde.dicX")

CONTEOS <- redatam.query(colombia, "freq MUPIO.REDCODEN
                      by CLASE.AREA
                      by PERSONA.P_SEXO
                      by PERSONA.P_EDAD
                      by PERSONA.UnidasR
                      by PERSONA.EDUCA
                      by PERSONA.PBLOPER
                      ", tot.omit = FALSE)
# Eliminando totales de la tabla
CONTEOS2 <- CONTEOS %>% filter_at(vars(matches("_label")),all_vars(. !=  "__tot__"))

#### elimando las edades menores a 10 años 

CONTEOS2 <- CONTEOS2 %>%  filter(P_EDAD4_value >= 12)
```

Después de realizar algunas validaciones se estandarizan las variables como muestra el siguiente código.

```{r, eval=FALSE}
censo_mrp <- CONTEOS2 %>%
  transmute(
    dam2 = str_pad(
      string = REDCODEN1_value,
      width = 5,
      pad = "0"
    ),
    area = case_when(AREA2_value == 1 ~ "1", # 1 = Urbana
                     TRUE ~ "0"  # 0 = Rural),
                     sexo = as.character(P_SEXO3_value),
                     
                     edad = case_when(P_EDAD4_value %in% 0:14 ~  "1",# 5 a 14
                                      P_EDAD4_value %in% 15:20 ~ "2",# 15 a 20
                                      P_EDAD4_value %in% 21:30 ~ "3",# 21 a 30
                                      P_EDAD4_value %in% 31:39 ~ "4",# 31 a 39
                                      P_EDAD4_value %in% 40:49 ~ "5",# 40 a 49TRUE ~ "6"
                     ),
                     
                     anoest = case_when(EDUCA6_value == 98  ~ "98",# No aplica
                                        EDUCA6_value == 99  ~ "99",#NS/NR
                                        EDUCA6_value == 1   ~ "1",# Sin educacion
                                        EDUCA6_value == 2   ~ "2",# 1-6
                                        EDUCA6_value == 3   ~ "3",# 7-12
                                        EDUCA6_value == 4   ~ "4" ,# 12 o mas
                                        TRUE ~ "Error"
                     ),
                     etnia = case_when(PBLOPER7_value %in% c(1) ~ "1",#indigena
                                       PBLOPER7_value %in% c(2) ~ "2",#afro negro mulato
                                       TRUE ~ "3"  # Otro
                     ),
                     
                     unida = case_when(UnidasR5_value == 1 ~ "1", # Unida
                                       TRUE ~ "2" # Otro
                                       ), 
                     value
                     ) %>% group_by(dam2, area, sexo,
                                    edad, etnia, anoest, unida) %>%
      summarise(n = sum(value), .groups = "drop")
```

La tabla resultante se muestra en la siguiente tabla. 

```{r}
censo_mrp <- readRDS("UNFPA/D6/censo_mrp.rds") 

tba(censo_mrp %>% head(10))
```


## Imagenes satelitales como información auxiliar

En la actualidad los datos satelitales que se usan para los diferentes estudios realizados por CEPAL, se obtienen de la plataforma Google Earth Engine ; la cual, integra diferentes lenguajes de programación como Javascript, Python y R mediante el paquete rgee, recientemente vinculado (2021). Todas estas herramientas juntas, permiten obtener imágenes satelitales de los lugares de interés para integrar a la información que ya se tiene disponible y así mejorar la calidad de las estimaciones.

La información satelital empleada para el calculo de los indicadores es la siguiente: 


-   Luces nocturnas 
    
    En su nombre original “Nighttime Lights Time Series Version 4, Defense Meteorological Program Operational Linescan System”. Este es un sistema de datos de uso público, recopilados por la Agencia Meteorológica de la Fuerza Aérea de EE. UU. Pero el procesamiento de las imágenes y los datos es realizado por el Centro Nacional de Datos Geofísicos de la NOAA.

-   Cubrimiento urbano y cubrimiento cultivo
 
    En su nombre original “Copernicus Global Land Cover Layers: CGLS-LC100 Collection 3” Estos mapas se encuentran disponibles para los periodos 2015-2019 en todo el mundo. Este esquema de clasificación según Google, puede representar áreas de cobertura terrestre heterogénea mejor que el esquema de clasificación estándar y, como tal, se puede adaptar para el uso de diferentes aplicaciones, por ejemplo, monitoreo forestal, monitoreo de cultivos, biodiversidad y conservación, monitoreo ambiental y seguridad en África, modelado climático, entre muchos otros.

La base consolidada es se muestra a continuación:  

```{r}
statelevel_predictors_df <- readRDS("UNFPA/D6/statelevel_predictors_df_dam2.rds")
tba(statelevel_predictors_df %>% head(10))
```


##	Modelo MRP

De acuerdo con este modelo, como lo expone Gutiérrez y otros (2022), la probabilidad de hacer uso de métodos de planificación para la $i$-ésima persona en el $j$-ésimo post-estrato, puede ser definido para cada unidad de la encuesta. El modelo pretende establecer la relación entre la expectativa $\rho_{di}$  de la variable dicotómica con las covariables de información auxiliar disponibles para ser incluidas. El procedimiento correspondiente a este proceso, modela el logaritmo del cociente entre la probabilidad de usar algún método anticonceptivo a su complemento en relación al conjunto de covariables a nivel de unidad, $x_{ji}$, y los efectos aleatorios $u_d$

$$
\ln(\frac{ρ_{ji}}{1-ρ_{ji}} ) = x_{ji}^t \beta + u_d.
$$

Los coeficientes $\beta$ hacen referencia a los efectos fijos de las variables $x_{ji}^T$  sobre las probabilidades de que la $i$-ésima persona haga uso de métodos anticonceptivos. Ahora, es posible asumir distribuciones no informativas para $\beta$ y $\sigma_u^2$. 

$$
\begin{eqnarray*}
\beta  & \sim & N(0,1000) \\
\sigma_u^2 & \sim & IG(0.001,0.001) 
\end{eqnarray*}
$$


## Estimación del modelo para D6

Se debe cargar el archivo `encuesta_mrp.rds` y el archivo `statelevel_predictors_df.rds` creado previamente. A continuaciones preparamos los datos para el indicador *D6*

```{r}
byAgrega <- c( "dam2", "area", "edad", "etnia",  
               "anoest", "unida")  

encuesta_df_agg <-
  encuesta_mrp %>%
  group_by_at(all_of(byAgrega)) %>%
  summarise(n = n(),
            pobres = sum(usametodo), #D6
            nopobres = n - pobres, .groups = "drop") 

encuesta_df_agg %<>% inner_join(statelevel_predictors_df,   by = "dam2") 
tba(encuesta_df_agg %>% head(10))

```


Con la información ordenada ajustamos el siguiente modelo 

```{r, eval=FALSE}
library(rstan)
library(rstantools)
library(rstanarm)
fit <- stan_glmer(
  cbind(pobres, nopobres) ~  (1 | dam2) +
    (1 | edad) +
    (1 | etnia) +
    (1 | area:anoest) +
    (1 | edad:anoest) +
    tasa_desocupacion +
    luces_nocturnas +
    cubrimiento_cultivo +
    cubrimiento_urbano +
    unida,
  family = binomial(link = "logit"),         
                 data = encuesta_df_agg,
                  verbose = TRUE,
                 cores = 7,
                 chains = 4,
                 iter = 1000
  )

saveRDS(fit, "UNFPA/D6/fit_bayes.rds")

```
El resultado del modelo es el siguiente. 
```{r}
fit<-readRDS("UNFPA/D6/fit_bayes.rds")
tba(coef(fit)$dam2 %>% head(10))
```

### Validación del modelo 

```{r}
library(posterior)
library(bayesplot)
posterior <- as.array(fit)
parameters <- dimnames(posterior)$parameters
# var_names <- grep(pattern = "area",x = parameters,value = TRUE)
 var_names <- c("luces_nocturnas", "cubrimiento_cultivo",
                "cubrimiento_urbano", "unida2"  )
mcmc_areas(fit, pars = var_names)
```


```{r}
mcmc_trace(fit,pars = var_names)
```


```{r, eval=FALSE}
encuesta_mrp2 <- inner_join(encuesta_mrp, statelevel_predictors_df)
y_pred_B <- posterior_epred(fit, newdata = encuesta_mrp2)
rowsrandom <- sample(nrow(y_pred_B), 100)
y_pred2 <- y_pred_B[rowsrandom, ]
ppc_dens_overlay(y = as.numeric(encuesta_mrp2$usametodo), y_pred2) 
  
```


```{r echo=FALSE, out.width = "800px", out.height="200px",fig.align='center'}
knitr::include_graphics("0Recursos/D6/ppc.PNG")
```

### Predicción en el censo

```{r, eval=FALSE}
poststrat_df <- censo_mrp %>%  
            group_by_at(byAgrega) %>%
            summarise(n = sum(n), .groups = "drop")

poststrat_df <- left_join(poststrat_df, statelevel_predictors_df,   by = "dam2")

epred_mat <- posterior_epred(fit, newdata = poststrat_df, 
                     type = "response", allow.new.levels = TRUE)
```


Asignar la predicción a la base de `poststrat_df`

```{r, eval=FALSE}
poststrat_df$epred_mat <- colMeans(epred_mat)
```

```{r, echo=FALSE}
poststrat_df <- readRDS("UNFPA/D6/poststrat_df_epred_mat.rds")
```


### Metodología de Benchmarking

1.  Validarse los nombres de las covariables disponibles en censo y encuesta, que deben ser las mismas con las que se han venido trabajando, para este caso resultaron 

```{r}
names_cov <- c("area" ,  "etnia" , "edad" , "unida" )
```

2. Calcular las estimaciones para cada una de las variables de la base de datos de `encuesta_mrp` utilizando el indicador de interés. 

```{r}
encuesta_mrp %<>% mutate(pobreza = usametodo, 
                         dam = substr(dam2,1,2))

paso <- sapply(names_cov, function(byi){
    encuesta_mrp %>% 
    group_by_at(all_of(byi)) %>% 
    summarise(Nhat = sum(fexp),
              t_pobreza = sum(pobreza*fexp),
              medias = weighted.mean(pobreza,fexp))
})

col_names <- names(unlist(paso["t_pobreza",])) 

data.frame( Categoría = unlist(paso["area",]),
           Total = unlist(paso["t_pobreza",]),
           Hat_Media = unlist(paso["medias",])) %>% slice(1:10) %>% 
  tba()


```

3.    Crear variables dummys en `poststrat_df` y multiplicar cada variable por la predicción `epred_mat`

```{r, eval=FALSE}
poststrat_df %<>%
  fastDummies::dummy_cols(select_columns = names_cov,   remove_selected_columns = FALSE)
poststrat_df %<>% 
       mutate_at(vars(matches("_\\d$")) ,~.*poststrat_df$epred_mat)
tba( poststrat_df %>% select(starts_with("edad"),epred_mat) %>% head(10))
```

```{r, echo=FALSE}
poststrat_df <- readRDS("UNFPA/D6/poststrat_dummy.rds")
```


4. Con la función `calib` se procede a calcular los $g_k$, verificando que el proceso se haya realizado con éxito y exista convergencia


```{r}
library(sampling)
poststrat_df$gk <- calib(
  Xs = poststrat_df %>% select(matches("_\\d{,2}$")), ## Variable dummys 
  d = poststrat_df$n,                            ## Conteos en el post-estrato
  total = unlist(paso["t_pobreza",]),            ## Valores objetivo
  method="logit")                                ## Método empleado

checkcalibration(Xs = poststrat_df %>% 
                 select(matches("_\\d{,2}$")), 
                 d = poststrat_df$n,
                 total = unlist(paso["t_pobreza",]),
                 g = poststrat_df$gk)
```

5. Realizar validación sobre los resultados obtenidos. 

```{r}
hist(poststrat_df$gk)
```

Continuando con la validación se define define la columna `pobreza2`

```{r}
poststrat_df %<>%
  mutate(pobreza2 = epred_mat *gk,
         pobreza2 = ifelse(pobreza2>1, 1, pobreza2),
         pobreza2 = ifelse(pobreza2<0, 0, pobreza2)) 

```

Paso seguido realizamos el calculo de los totales calibrados. 
```{r}
temp <- map_df(names_cov ,~ poststrat_df %>% 
              group_by_at(all_of(.x)) %>%
              summarise(
              Nhat = sum(n),
              t_pobreza = sum(n*pobreza2)) %>% 
              transmute(
                Cal_Media = t_pobreza/Nhat,
                Variable = paste0(.x, get(.x) ))) 

data.frame( Categoría = unlist(paso["area",]),
            Hat_Media = unlist(paso["medias",])) %>% 
  cbind(temp) %>% head(10) %>% tba()
```

También es posible hacer validaciones visuales. 

```{r, fig.align='center', eval=FALSE}
library(survey)
library(srvyr)
library(patchwork)
source("0Recursos/funciones_mrp.R")

poststrat_df %<>% mutate(yk_lmer = epred_mat,   yk_bench = pobreza2)

diseno <- encuesta_mrp %>%
  mutate(yk_dir = pobreza,
         dam = substr(dam2,1,2)) %>% 
  as_survey_design(weights = fexp)

bynames <- c("area", "edad", "dam", "etnia")
plot_uni <- map(
  .x = setNames(bynames, bynames),
  ~ plot_compare2(
    sample_diseno = diseno,
    poststrat = poststrat_df,
    by1 = .x
  )
)

plot_uni$dam$Plot$plot1/

(plot_uni$edad$Plot$plot1 +
plot_uni$area$Plot$plot1+ plot_uni$etnia$Plot$plot1)

```


```{r echo=FALSE, out.width = "800px", out.height="200px",fig.align='center'}
knitr::include_graphics("0Recursos/D6/plot_uni.PNG")
```

### Estimación y mapa del indicador. 

Después de todos el proceso de estandarización, creación de variables covariables, estimación del modelo y validaciones realizadas, la estimación puntual se reduce a operaciones algebraicas simples. 

```{r}
poststrat_df2 <-  poststrat_df %>% filter(anoest != "99")

dat_dam2 <- poststrat_df2 %>% group_by(dam2) %>%
    summarise(
      Benchmarking_estimate = sum(n * pobreza2) / sum(n),
      .groups = "drop"
    )
```

En este paso validamos que las estimaciones no superen el valor de 1 o sean menores o iguales a creo. 
```{r}
dat_dam2 %>% summarise(Validar = sum(Benchmarking_estimate >= 1 |                     Benchmarking_estimate < 0  ))
  
```

El cuadrado medio del error lo obtenemos con la función `Aux_Agregado` que hemos usado previamente. 

```{r, eval=FALSE}
mrp_cme <-
  Aux_Agregado(poststrat = poststrat_df,
             epredmat = epred_mat,
             byMap = "dam2") %>% 
  select(-mrp_estimate)

dat_dam2 <- dat_dam2 %>% left_join(mrp_cme) %>% 
  mutate(mrp_cv = mrp_estimate_se/Benchmarking_estimate*100) %>% 
  arrange(desc(mrp_cv))
tba(dat_dam2 %>% slice(1:10))

```

```{r, echo=FALSE}
dat_dam2 <- readRDS("UNFPA/D6/dat_dam2.rds")
tba(dat_dam2 %>% slice(1:10))
```


### Mapas para el indicador D6


```{r, eval=FALSE}
library(sp)
library(sf)
library(tmap)

ShapeSAE <- read_sf("Shape/COL_dam2.shp")


P1_ingresolp <- tm_shape(ShapeSAE %>%    left_join(dat_dam2,  by = "dam2"))

brks_lp <- c(0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 1)
tmap_options(check.and.fix = TRUE)
Mapa_lp <-
  P1_ingresolp + tm_polygons(
    "Benchmarking_estimate",
    breaks = brks_lp,
    title = "D6",
    palette = "-YlOrRd"
  ) + tm_layout(asp = 0)

tmap_save(
  Mapa_lp,
  "UNFPA/D6/Estados2.jpeg",
  width = 6920,
  height = 4080,
  asp = 0
)
Mapa_lp
```


```{r echo=FALSE, out.width = "800px", out.height="200px",fig.align='center'}
knitr::include_graphics("UNFPA/D6/Estados2.jpeg")
```

## Estimación del indicador D6m (Uso de métodos anticonceptivos) 

El procedimiento descrito previamente se repite para los indicadores *D6m* y *NI*. 

Lectura de insumos 

```{r}
encuesta_mrp <- readRDS("UNFPA/D6m/encuesta_mrp.rds")  %>% 
  rename(dam2 = mpio)
statelevel_predictors_df <- readRDS("UNFPA/D6m/statelevel_predictors_df_dam2.rds")
censo_mrp <- readRDS("UNFPA/D6m/censo_mrp.rds")
fit <- readRDS("UNFPA/D6m/fit_bayes.rds")
```

Por el proceso de estandarizado realizado es renombrado el indicador _usamoderno_ como _probreza_, el modelo contemplado para el indicador es:  

```{r}
fit$call
```

El resultado del modelo es el siguiente. 
```{r}
tba(coef(fit)$dam2 %>% head(10))
```

### Validación del modelo 

```{r}
library(posterior)
library(bayesplot)
posterior <- as.array(fit)
mcmc_areas(fit, pars = var_names)
```


```{r}
mcmc_trace(fit,pars = var_names)
```


```{r, eval=FALSE}
encuesta_mrp2 <- inner_join(encuesta_mrp, statelevel_predictors_df)
y_pred_B <- posterior_epred(fit, newdata = encuesta_mrp2)
rowsrandom <- sample(nrow(y_pred_B), 100)
y_pred2 <- y_pred_B[rowsrandom, ]
ppc_dens_overlay(y = as.numeric(encuesta_mrp2$usamoderno), y_pred2) 
  
```


```{r echo=FALSE, out.width = "500px", out.height="250px",fig.align='center'}
 knitr::include_graphics("0Recursos/D6m/ppc.PNG")
```

### Predicción en el censo

```{r, eval=FALSE}
 byAgrega <- c("dam2", "area", "edad", "etnia",
               "anoest", "unida")

poststrat_df <- censo_mrp %>%  
            group_by_at(byAgrega) %>%
            summarise(n = sum(n), .groups = "drop")

poststrat_df <- left_join(poststrat_df, statelevel_predictors_df)

epred_mat <- posterior_epred(fit, newdata = poststrat_df, 
                     type = "response", allow.new.levels = TRUE)
```

Asignar la predicción a la base de `poststrat_df`

```{r, eval=FALSE}
poststrat_df$epred_mat <- colMeans(epred_mat)
```

```{r, echo=FALSE}
poststrat_df <- readRDS("UNFPA/D6m/poststrat_df_epred_mat.rds")
```


### Metodología Benchmarking

1.  Validarse los nombres de las covariables disponibles en censo y encuesta, que deben ser las mismas con las que se han venido trabajando, para este caso resultaron 

```{r}
names_cov <- c("area" , "etnia", "edad" , "unida")
```

2. Calcular las estimaciones para cada una de las variables de la base de datos de `encuesta_mrp` utilizando el indicador de interés. 

```{r}
encuesta_mrp %<>% mutate(pobreza = usamoderno)

paso <- sapply(names_cov, function(byi){
    encuesta_mrp %>% 
    group_by_at(all_of(byi)) %>% 
    summarise(Nhat = sum(fexp),
              t_pobreza = sum(pobreza*fexp),
              medias = weighted.mean(pobreza,fexp))
})

data.frame( Categoría = unlist(paso["area",]),
           Total = unlist(paso["t_pobreza",]),
           Hat_Media = unlist(paso["medias",])) %>% head(10) %>% 
  tba()

```

3.    Crear variables dummys en `poststrat_df` y multiplicar cada variable por la predicción `epred_mat`

```{r}
poststrat_df %<>%
  fastDummies::dummy_cols(select_columns = names_cov,   remove_selected_columns = FALSE)
poststrat_df %<>% 
       mutate_at(vars(matches("_\\d$")) ,~.*poststrat_df$epred_mat)

```


```{r, echo=FALSE}
poststrat_df <- readRDS("UNFPA/D6m/poststrat_dummy.rds")
```


4. Con la función `calib` se procede a calcular los $g_k$, verificando que el proceso se haya realizado con éxito y exista convergencia


```{r}
library(sampling)

poststrat_df$gk <- calib(
  Xs = poststrat_df %>% select(matches("_\\d{,2}$")), ## Variable dummys 
  d = poststrat_df$n,                            ## Conteos en el post-estrato
  total = unlist(paso["t_pobreza",]),            ## Valores objetivo
  method="logit")                                ## Método empleado

checkcalibration(Xs = poststrat_df %>% 
                 select(matches("_\\d{,2}$")), 
                 d = poststrat_df$n,
                 total = unlist(paso["t_pobreza",]),
                 g = poststrat_df$gk)
```

5. Realizar validación sobre los resultados obtenidos. 

```{r}
hist(poststrat_df$gk)
```

Continuando con la validación se define define la columna `pobreza2`

```{r}
poststrat_df %<>%
  mutate(pobreza2 = epred_mat *gk,
         pobreza2 = ifelse(pobreza2>1, 1, pobreza2),
         pobreza2 = ifelse(pobreza2<0, 0, pobreza2)) 

```

Paso seguido realizamos el calculo de los totales calibrados. 
```{r}
temp <- map_df(names_cov ,~ poststrat_df %>% 
              group_by_at(all_of(.x)) %>%
              summarise(
              Nhat = sum(n),
              t_pobreza = sum(n*pobreza2)) %>% 
              transmute(
                Cal_Media = t_pobreza/Nhat,
                Variable = paste0(.x, get(.x) ))) 

data.frame( Categoría = unlist(paso["area",]),
            Hat_Media = unlist(paso["medias",])) %>% 
  cbind(temp) %>% head(10) %>% tba()
```

También es posible hacer validaciones visuales. 

```{r, eval=FALSE}
library(survey)
library(srvyr)
library(patchwork)
source("0Recursos/funciones_mrp.R")

poststrat_df %<>% mutate(yk_lmer = epred_mat,   yk_bench = pobreza2)


diseno <- encuesta_mrp %>%
  mutate(yk_dir = pobreza,
         dam = substr(dam2,1,2)) %>% 
  as_survey_design(weights = fexp)

bynames <- c("area", "edad", "dam", "etnia")
plot_uni <- map(
  .x = setNames(bynames, bynames),
  ~ plot_compare2(
    sample_diseno = diseno,
    poststrat = poststrat_df,
    by1 = .x
  )
)

plot_uni$dam$Plot$plot1/

(plot_uni$edad$Plot$plot1 +
plot_uni$area$Plot$plot1+ plot_uni$etnia$Plot$plot1)
```


```{r echo=FALSE, out.width = "500px", out.height="250px",fig.align='center'}
 knitr::include_graphics("0Recursos/D6m/plot_uni.PNG")
```

### Estimación y mapa del indicador D6m. 

Después de todos el proceso de estandarización, creación de variables covariables, estimación del modelo y validaciones realizadas, la estimación puntual se reduce a operaciones algebraicas simples. 

```{r, eval=FALSE}
poststrat_df2 <-  poststrat_df %>% filter(anoest != "99")

dat_dam2 <- poststrat_df2 %>% group_by(dam2) %>%
    summarise(
      Benchmarking_estimate = sum(n * pobreza2) / sum(n),
      .groups = "drop"
    )
```


El cuadrado medio del error lo obtenemos con la función `Aux_Agregado` que hemos usado previamente. 

```{r, eval=FALSE}
mrp_cme <-
  Aux_Agregado(poststrat = poststrat_df,
             epredmat = epred_mat,
             byMap = "dam2") %>% 
  select(-mrp_estimate)

dat_dam2 <- dat_dam2 %>% left_join(mrp_cme) %>% 
  mutate(mrp_cv = mrp_estimate_se/Benchmarking_estimate*100) %>% 
  arrange(desc(mrp_cv))

tba(dat_dam2 %>% slice(1:10))

```

```{r, echo=FALSE}
dat_dam2 <- readRDS(file = "UNFPA/D6m/dat_dam2.rds")
tba(dat_dam2 %>% slice(1:10))
```


### Mapas para el indicador D6m


```{r, eval=FALSE}
library(sp)
library(sf)
library(tmap)
ShapeSAE <- read_sf("Shape/COL_dam2.shp")

P1_ingresolp <- tm_shape(ShapeSAE %>%    left_join(dat_dam2,  by = "dam2"))

brks_lp <- c(0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 1)
tmap_options(check.and.fix = TRUE)
Mapa_lp <-
  P1_ingresolp + tm_polygons(
    "Benchmarking_estimate",
    breaks = brks_lp,
    title = "D6m",
    palette = "-YlOrRd"
  ) + tm_layout(asp = 0)

tmap_save(
  Mapa_lp,
  "UNFPA/D6m/Estados2.jpeg",
  width = 6920,
  height = 4080,
  asp = 0
)
Mapa_lp
```


```{r echo=FALSE, out.width = "800px", out.height="200px",fig.align='center'}
knitr::include_graphics("UNFPA/D6m/Estados2.jpeg")
```

## Estimación del indicador NI (Necesidades Insatisfechas) 

Lectura de insumos 

```{r}
encuesta_mrp <- readRDS("UNFPA/NI/encuesta_mrp.rds") %>% 
  rename(dam2 = mpio)
statelevel_predictors_df <- readRDS("UNFPA/NI/statelevel_predictors_df_dam2.rds")
censo_mrp <- readRDS("UNFPA/NI/censo_mrp.rds")
fit <- readRDS("UNFPA/NI/fit_bayes.rds")
```

Por el proceso de estandarizado realizado es renombrado el indicador _necesInst_ como _probreza_, el modelo contemplado para el indicador es:  

```{r}
fit$call
```

El resultado del modelo es el siguiente. 
```{r}
tba(coef(fit)$dam2 %>% head(10))
```

### Validación del modelo 

```{r}
library(posterior)
library(bayesplot)
posterior <- as.array(fit)
mcmc_areas(fit, pars = var_names)
```


```{r}
mcmc_trace(fit,pars = var_names)
```


```{r, eval = FALSE}
encuesta_mrp2 <- inner_join(encuesta_mrp, statelevel_predictors_df)
y_pred_B <- posterior_epred(fit, newdata = encuesta_mrp2)
rowsrandom <- sample(nrow(y_pred_B), 100)
y_pred2 <- y_pred_B[rowsrandom, ]
ppc_dens_overlay(y = as.numeric(encuesta_mrp2$necesInst), y_pred2) 
  
```



### Predicción en el censo

```{r, eval=FALSE}
poststrat_df <- censo_mrp %>%  
            group_by_at(byAgrega) %>%
            summarise(n = sum(n), .groups = "drop")

poststrat_df <- left_join(poststrat_df, statelevel_predictors_df)

epred_mat <- posterior_epred(fit, newdata = poststrat_df, 
                     type = "response", allow.new.levels = TRUE)
```

Asignar la predicción a la base de `poststrat_df`

```{r, eval=FALSE}
poststrat_df$epred_mat <- colMeans(epred_mat)
```

```{r, echo=FALSE}
poststrat_df <- readRDS("UNFPA/NI/poststrat_epred_mat.rds")
```


### Metodología de Benchmarking

1.  Validarse los nombres de las covariables disponibles en censo y encuesta, que deben ser las mismas con las que se han venido trabajando, para este caso resultaron 

```{r}
names_cov <- c("area",  "etnia", "edad" , "unida" )
```

2. Calcular las estimaciones para cada una de las variables de la base de datos de `encuesta_mrp` utilizando el indicador de interés. 

```{r}
encuesta_mrp %<>% mutate(pobreza = necesInst)

paso <- sapply(names_cov, function(byi){
    encuesta_mrp %>% 
    group_by_at(all_of(byi)) %>% 
    summarise(Nhat = sum(fexp),
              t_pobreza = sum(pobreza*fexp),
              medias = weighted.mean(pobreza,fexp))
})

data.frame( Categoría = unlist(paso["area",]),
           Total = unlist(paso["t_pobreza",]),
           Hat_Media = unlist(paso["medias",])) %>% 
  head(10) %>% tba()

```

3.    Crear variables dummys en `poststrat_df` y multiplicar cada variable por la predicción `epred_mat`


```{r, eval=FALSE}
poststrat_df %<>%
  fastDummies::dummy_cols(select_columns = names_cov,   remove_selected_columns = FALSE)
poststrat_df %<>% 
       mutate_at(vars(matches("_\\d$")) ,~.*poststrat_df$epred_mat)
```

```{r, echo=FALSE}
poststrat_df <- readRDS("UNFPA/NI/poststrat_dummy.rds")
```


4. Con la función `calib` se procede a calcular los $g_k$, verificando que el proceso se haya realizado con éxito y exista convergencia


```{r}
library(sampling)

poststrat_df$gk <- calib(
  Xs = poststrat_df %>% select(matches("_\\d{,2}$")), ## Variable dummys 
  d = poststrat_df$n,                            ## Conteos en el post-estrato
  total = unlist(paso["t_pobreza",]),            ## Valores objetivo
  method="logit")                                ## Método empleado

checkcalibration(Xs = poststrat_df %>% 
                 select(matches("_\\d{,2}$")), 
                 d = poststrat_df$n,
                 total = unlist(paso["t_pobreza",]),
                 g = poststrat_df$gk)
```

5. Realizar validación sobre los resultados obtenidos. 

```{r}
hist(poststrat_df$gk)
```

Continuando con la validación se define define la columna `pobreza2`

```{r}
poststrat_df %<>%
  mutate(pobreza2 = epred_mat *gk,
         pobreza2 = ifelse(pobreza2>1, 1, pobreza2),
         pobreza2 = ifelse(pobreza2<0, 0, pobreza2)) 

```

Paso seguido realizamos el calculo de los totales calibrados. 
```{r}
temp <- map_df(names_cov ,~ poststrat_df %>% 
              group_by_at(all_of(.x)) %>%
              summarise(
              Nhat = sum(n),
              t_pobreza = sum(n*pobreza2)) %>% 
              transmute(
                Cal_Media = t_pobreza/Nhat,
                Variable = paste0(.x, get(.x) ))) 

data.frame( Categoría = unlist(paso["area",]),
            Hat_Media = unlist(paso["medias",])) %>% 
  cbind(temp) %>% head(10) %>% tba()
```

También es posible hacer validaciones visuales. 

```{r, eval=FALSE}
library(survey)
library(srvyr)
library(patchwork)
source("0Recursos/funciones_mrp.R")

poststrat_df %<>% mutate(yk_lmer = epred_mat,   yk_bench = pobreza2)

diseno <- encuesta_mrp %>%
  mutate(yk_dir = pobreza,
         dam = substr(dam2,1,2)) %>% 
  as_survey_design(weights = fexp)

bynames <- c("area", "edad", "dam", "etnia")
plot_uni <- map(
  .x = setNames(bynames, bynames),
  ~ plot_compare2(
    sample_diseno = diseno,
    poststrat = poststrat_df,
    by1 = .x
  )
)

plot_uni$dam$Plot$plot1/

(plot_uni$edad$Plot$plot1 +
plot_uni$area$Plot$plot1+ plot_uni$etnia$Plot$plot1)

```


```{r echo=FALSE, out.width = "500px", out.height="250px",fig.align='center'}
 knitr::include_graphics("0Recursos/NI/plot_uni.PNG")
```

### Estimación y mapa del indicador. 

Después de todos el proceso de estandarización, creación de variables covariables, estimación del modelo y validaciones realizadas, la estimación puntual se reduce a operaciones algebraicas simples. 

```{r, eval = FALSE}
poststrat_df2 <-  poststrat_df %>% filter(anoest != "99")

dat_dam2 <- poststrat_df2 %>% group_by(dam2) %>%
    summarise(
      Benchmarking_estimate = sum(n * pobreza2) / sum(n),
      .groups = "drop"
    )
```


El cuadrado medio del error lo obtenemos con la función `Aux_Agregado` que hemos usado previamente. 

```{r, eval=FALSE}
mrp_cme <-
  Aux_Agregado(poststrat = poststrat_df,
             epredmat = epred_mat,
             byMap = "dam2") %>% 
  select(-mrp_estimate)

dat_dam2 <- dat_dam2 %>% left_join(mrp_cme) %>% 
  mutate(mrp_cv = mrp_estimate_se/Benchmarking_estimate*100) %>% 
  arrange(desc(mrp_cv))

tba(dat_dam2 %>% slice(1:10))

```

```{r, echo=FALSE}
dat_dam2 <- readRDS(file = "UNFPA/NI/dat_dam2.rds")
tba(dat_dam2 %>% slice(1:10))
```

### Mapas para el indicador NI


```{r, eval=FALSE}
library(sp)
library(sf)
library(tmap)

ShapeSAE <- read_sf("Shape/COL_dam2.shp")

P1_ingresolp <- tm_shape(ShapeSAE %>%    left_join(dat_dam2,  by = "dam2"))

tmap_options(check.and.fix = TRUE)
Mapa_lp <-
  P1_ingresolp + tm_polygons(
    "Benchmarking_estimate",
    title = "NI",
    palette = "YlOrRd"
  ) + tm_layout(asp = 0)

tmap_save(
  Mapa_lp,
  "UNFPA/NI/Estados2.jpeg",
  width = 6920,
  height = 4080,
  asp = 0
)
Mapa_lp
```


```{r echo=FALSE, out.width = "800px", out.height="200px",fig.align='center'}
knitr::include_graphics("UNFPA/NI/Estados2.jpeg")
```

# Día 4 - Sesión 4- Estimación del indicador D7  

Este indicador, hace referencia a la proporción de mujeres en edad de procrear (15 a 49 años), sexualmente activas y/o unidas que han decidido por voluntad propia no tener hijos (adicionales) o posponer su siguiente hijo y para ello se encuentran utilizando métodos anticonceptivos modernos. 

Lectura de insumos 

```{r, eval=FALSE}
encuesta_mrp <- readRDS("UNFPA/NI/encuesta_mrp.rds") %>% 
  rename(dam2 = mpio)
censo_mrp <- readRDS("UNFPA/NI/censo_mrp.rds")
statelevel_predictors_df <- readRDS("UNFPA/NI/statelevel_predictors_df_dam2.rds")

fit_mrp_logit_D6  <- readRDS("UNFPA/D6/fit_bayes.rds")
fit_mrp_logit_D6m <- readRDS("UNFPA/D6m/fit_bayes.rds")
fit_mrp_logit_NI  <- readRDS("UNFPA/NI/fit_bayes.rds")
```

## Predicción en el censo

```{r, eval=FALSE}
poststrat_df <- censo_mrp %>%  
            group_by_at(byAgrega) %>%
            summarise(n = sum(n), .groups = "drop")

poststrat_df <- left_join(poststrat_df, statelevel_predictors_df,   by = "dam2")
```

Ahora debemos hacer la predicción sobre la base _poststrat_df_ con los tres modelos 
```{r, eval=FALSE}
### Creando epredmat Para D6
epred_mat_D6 <- posterior_epred(fit_mrp_logit_D6, newdata = poststrat_df, 
                     type = "response", allow.new.levels = TRUE)

### Creando epredmat Para D6m
epred_mat_D6m <- posterior_epred(fit_mrp_logit_D6m, newdata = poststrat_df,  type = "response", allow.new.levels = TRUE)

### Creando epredmat Para NI
epred_mat_NI <- posterior_epred(fit_mrp_logit_NI, newdata = poststrat_df,  type = "response", allow.new.levels = TRUE)

```

El indicador  *D7* se construye a partir de las predicciones 
```{r, eval=FALSE}
epred_mat_D7<- (epred_mat_D6m /(epred_mat_D6 + epred_mat_NI))
```

## Estimación y mapa del indicador. 

Después de todos el proceso de estandarización, creación de variables covariables, estimación del modelo y validaciones realizadas, la estimación puntual se reduce a operaciones algebraicas simples. 

```{r, eval=FALSE}
poststrat_df2 <-  poststrat_df %>% filter(anoest != "99")

dat_dam2 <- Aux_Agregado(poststrat = poststrat_df,
                 epredmat = epred_mat_D7,
                 byMap = "dam2") %>% 
  mutate(mrp_cv = mrp_estimate_se/mrp_estimate *100)

dat_dam2 %>% arrange(desc(mrp_cv)) %>% head(10) %>% tba()
```

```{r, echo=FALSE}
dat_dam2 <- readRDS("UNFPA/D7/dat_dam2.rds")
dat_dam2 %>% arrange(desc(mrp_cv)) %>% head(10) %>% tba()
```

## Mapas para el indicador D7


```{r, eval=FALSE}
library(sp)
library(sf)
library(tmap)

ShapeSAE <- read_sf("Shape/COL_dam2.shp")

P1_ingresolp <- tm_shape(ShapeSAE %>% 
                           left_join(dat_dam2,  by = "dam2"))

brks_lp <- c(0, 0.20,  0.4, 0.6,  0.8 , 1)
tmap_options(check.and.fix = TRUE)
Mapa_lp <-
  P1_ingresolp + tm_polygons(
    "mrp_estimate",
    breaks = brks_lp,
    title = "D7",
    palette = "-YlOrRd"
  ) + tm_layout(asp = 0)

tmap_save(
  Mapa_lp,
  "UNFPA/D7/Estados2.jpeg",
  width = 6920,
  height = 4080,
  asp = 0
)
Mapa_lp
```


```{r echo=FALSE, out.width = "800px", out.height="200px",fig.align='center'}
knitr::include_graphics("UNFPA/D7/Estados2.jpeg")
```

