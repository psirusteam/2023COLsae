[["index.html", "Desagregación de datos en encuestas de hogares: metodologías bayesianas para modelos de estimación en áreas pequeñas Agenda", " Desagregación de datos en encuestas de hogares: metodologías bayesianas para modelos de estimación en áreas pequeñas Andrés Gutiérrez1, Stalyn Guerrero2 2023-03-20 Agenda Experto Regional en Estadísticas Sociales - Comisión Económica para América Latina y el Caribe (CEPAL) - andres.gutierrez@cepal.org↩︎ Consultor - Comisión Económica para América Latina y el Caribe (CEPAL), guerrerostalyn@gmail.com↩︎ "],["censo-e-información-satelital.html", "Capítulo 1 Censo e información satelital", " Capítulo 1 Censo e información satelital "],["uso-de-imágenes-satelitales-y-sae.html", "Capítulo 2 Uso de imágenes satelitales y SAE", " Capítulo 2 Uso de imágenes satelitales y SAE Uno de los artículo pioneros de estimación de áreas pequeñas fue el artículo de Singh, R, et. al. (2002) el cual abordó la estimación del rendimiento de cultivos para los tehsil (unidad subadministrativa) del distriyo Rohtak district en Haryana (India). Las imágenes raster representan el mundo mediante un conjunto de celdas contiguas igualmente espaciadas conocidas como pixeles, estas imágenes tienen información como un sistema de información geográfico, Un sistema de referencia de coordenadas. Las imágenes almacenan un identificador, un valor en cada pixel (o un vector con diferentes valores) y cada celda tiene asociada una escala de colores. Las imágenes pueden obtenerse crudas y procesadas, estas primeras contienen solamente las capas de colores, las segundas contienen también valores que han sido procesados en cada celda (índices de vegetación, intensidad lumínica, tipo de vegetación). La información cruda puede utilizarse para entrenar características que se desean entrenar (carreteras, tipo de cultivo, bosque / no bosque), afortunadamente en Google Earth Engine encontramos muchos indicadores procesadas asociadas a un pixel. Estos indicadores pueden agregarse a nivel de un área geográfica. 2.0.1 Fuentes de datos de imágenes satelitales Algunas de las principales fuentes de imágenes satelitales son: http://earthexplorer.usgs.gov/ https://lpdaacsvc.cr.usgs.gov/appeears/ https://search.earthdata.nasa.gov/search https://scihub.coGTMnicus.eu/ https://aws.amazon.com/public-data-sets/landsat/ Sin embargo la mayor parte de estas fuentes están centralizadas en Google Earth Engine que permite buscar fuentes de datos provenientes de imágenes satelitales. GEE se puede manejar por medio de APIS en diferentes lenguajes de programación: Javascript (por defecto), Python y R (paquete rgee). "],["google-earth-eninge.html", "Capítulo 3 Google Earth Eninge", " Capítulo 3 Google Earth Eninge Crear una cuenta en link, una vez que se ingrese a la cuenta puede buscarse los conjuntos de datos de interés: Una vez se busque el conjunto de datos se puede abrir un editor de código brindado por google en Javascript. Copiar y pegar la sintaxis que brinda el buscador de conjunto de datos para visualizar la imagen raster y disponer de sentencias que GTMmitan la obtención del conjunto de datos de interés posteriormente en R "],["instalación-de-rgee.html", "Capítulo 4 Instalación de rgee", " Capítulo 4 Instalación de rgee Descargar e instalar anaconda o conda. (https://www.anaconda.com/products/individual) Abrir Anaconda prompt y configurar ambiente de trabajo (ambiente python rgee_py) con las siguientes sentencias: conda create -n rgee_py python=3.9 activate rgee_py pip install google-api-python-client pip install earthengine-api pip install numpy Listar los ambientes de Python disponibles en anaconda prompt conda env list Una vez identificado la ruta del ambiente ambiente rgee_py definirla en R (no se debe olvidar cambiar \\ por /). Instalar reticulate y rgee, cargar paquetes para procesamiento espacial y configurar el ambiente de trabajo como sigue: library(reticulate) # Conexión con Python library(rgee) # Conexión con Google Earth Engine library(sf) # Paquete para manejar datos geográficos library(dplyr) # Paquete para procesamiento de datos rgee_environment_dir = &quot;C://Users//sguerrero//Anaconda3//envs//rgee_py//python.exe&quot; # Configurar python (Algunas veces no es detectado y se debe reiniciar R) reticulate::use_python(rgee_environment_dir, required=T) rgee::ee_install_set_pyenv(py_path = rgee_environment_dir, py_env = &quot;rgee_py&quot;) Sys.setenv(RETICULATE_PYTHON = rgee_environment_dir) Sys.setenv(EARTHENGINE_PYTHON = rgee_environment_dir) Una vez configurado el ambiente puede iniciarlizarse una sesión de Google Earth Engine como sigue: rgee::ee_Initialize(drive = T) Notas: Se debe inicializar cada sesión con el comando rgee::ee_Initialize(drive = T). Los comandos de javascript que invoquen métodos con “.” se sustituyen por signo peso ($), por ejemplo: ee.ImageCollection().filterDate() # Javascript ee$ImageCollection()$filterDate() # R "],["descargar-información-satelital.html", "4.1 Descargar información satelital", " 4.1 Descargar información satelital Paso 1: disponer de los shapefile # shape &lt;- read_sf(&quot;Shape/COL_dam2.shp&quot;) shape &lt;- read_sf(&quot;Recursos/Día1/Sesion3/Shape/COL.shp&quot;) plot(shape[&quot;geometry&quot;]) Paso 2: Seleccionar el archivo de imágenes que desea procesar, para nuestro ejemplo luces nocturnas. luces &lt;- ee$ImageCollection(&quot;NOAA/DMSP-OLS/NIGHTTIME_LIGHTS&quot;) %&gt;% ee$ImageCollection$filterDate(&quot;2013-01-01&quot;, &quot;2014-01-01&quot;) %&gt;% ee$ImageCollection$map(function(x) x$select(&quot;stable_lights&quot;)) %&gt;% ee$ImageCollection$toBands() Paso 3: Descargar la información ## Tiempo 10 minutos shape_luces &lt;- map(unique(shape$dam), ~tryCatch(ee_extract( x = luces, y = shape[&quot;dam&quot;] %&gt;% filter(dam == .x), ee$Reducer$mean(), sf = FALSE ) %&gt;% mutate(dam = .x), error = function(e)data.frame(dam = .x))) shape_luces %&lt;&gt;% bind_rows() tba(shape_luces, cap = &quot;Promedio de luces nocturnasa&quot;) "],["repetir-la-rutina-para.html", "4.2 Repetir la rutina para:", " 4.2 Repetir la rutina para: Tipo de suelo: crops-coverfraction (Porcentaje de cubrimiento cultivos) y urban-coverfraction (Porcentaje de cobertura urbana) disponibles en https://develoGTMs.google.com/earth-engine/datasets/catalog/COGTMNICUS_Landcover_100m_Proba-V-C3_Global#description Tiempo de viaje al hospital o clínica más cercana (accessibility) y tiempo de viaje al hospital o clínica más cercana utilizando transporte no motorizado (accessibility_walking_only) información disponible en https://develoGTMs.google.com/earth-engine/datasets/catalog/Oxford_MAP_accessibility_to_healthcare_2019 Modificación humana, donde se consideran los asentamiento humano, la agricultura, el transporte, la minería y producción de energía e infraestructura eléctrica. En el siguiente link encuentra la información satelital https://develoGTMs.google.com/earth-engine/datasets/catalog/CSP_HM_GlobalHumanModification#description Paso 4 consolidar la información. dam luces_nocturnas cubrimiento_cultivo cubrimiento_urbano modificacion_humana accesibilidad_hospitales accesibilidad_hosp_caminado 05 2.3809 1.2755 0.6900 0.2947 181.1119 420.4946 08 13.0102 9.7734 4.7396 0.4943 28.2639 154.5701 11 21.5163 9.7879 19.8337 0.5509 60.7259 267.8848 13 1.9374 1.9246 0.6285 0.2911 216.2115 501.9515 15 2.6495 13.8033 0.5758 0.2965 115.8310 309.3832 17 4.4541 2.5939 0.8696 0.3639 62.2349 228.6569 18 0.0877 0.2771 0.0456 0.1248 1218.6141 2505.8205 19 1.4020 4.0623 0.3414 0.2231 214.3356 406.7882 20 2.6586 10.6343 0.4973 0.3349 99.1499 365.6516 23 2.2205 10.5568 0.5211 0.3331 141.3763 441.9516 Los resultados se muestran en los siguientes mapas "],["luces-nocturnas.html", "4.3 Luces nocturnas", " 4.3 Luces nocturnas "],["cubrimiento-cultivos.html", "4.4 Cubrimiento cultivos", " 4.4 Cubrimiento cultivos "],["cubrimiento-urbanos.html", "4.5 Cubrimiento urbanos", " 4.5 Cubrimiento urbanos "],["modificación-humana.html", "4.6 Modificación humana", " 4.6 Modificación humana "],["tiempo-promedio-al-hospital.html", "4.7 Tiempo promedio al hospital", " 4.7 Tiempo promedio al hospital "],["tiempo-promedio-al-hospital-en-vehiculo-no-motorizado.html", "4.8 Tiempo promedio al hospital en vehiculo no motorizado", " 4.8 Tiempo promedio al hospital en vehiculo no motorizado "],["resultados-de-la-información-censal..html", "4.9 Resultados de la información censal.", " 4.9 Resultados de la información censal. predictors_censo_dam &lt;- readRDS(&quot;Recursos/Día1/Sesion3/Data/predictors_censo_dam.rds&quot;) temp2 &lt;- inner_join(shape[&quot;dam&quot;], predictors_censo_dam) for(ii in names(predictors_censo_dam[,-1])){ plot( temp2[ii], key.pos = 4, breaks = quantile(temp2[[ii]])) } "],["fundamentos-de-la-inferencia-bayesiana-en-r-y-stan.html", "Capítulo 5 Fundamentos de la inferencia Bayesiana en R y STAN ", " Capítulo 5 Fundamentos de la inferencia Bayesiana en R y STAN "],["regla-de-bayes.html", "5.1 Regla de Bayes", " 5.1 Regla de Bayes En términos de inferencia para \\(\\boldsymbol{\\theta}\\), es necesario encontrar la distribución de los parámetros condicionada a la observación de los datos. Para este fin, es necesario definir la distribución conjunta de la variable de interés con el vector de parámetros. \\[ p(\\boldsymbol{\\theta},\\mathbf{Y})=p(\\boldsymbol{\\theta})p(\\mathbf{Y} \\mid \\boldsymbol{\\theta}) \\] La distribución \\(p(\\boldsymbol{\\theta})\\) se le conoce con el nombre de distribución previa. El término \\(p(\\mathbf{Y} \\mid \\boldsymbol{\\theta})\\) es la distribución de muestreo, verosimilitud o distribución de los datos. La distribución del vector de parámetros condicionada a los datos observados está dada por \\[ p(\\boldsymbol{\\theta} \\mid \\mathbf{Y})=\\frac{p(\\boldsymbol{\\theta},\\mathbf{Y})}{p(\\mathbf{Y})}=\\frac{p(\\boldsymbol{\\theta})p(\\mathbf{Y} \\mid \\boldsymbol{\\theta})}{p(\\mathbf{Y})} \\] A la distribución \\(p(\\boldsymbol{\\theta} \\mid \\mathbf{Y})\\) se le conoce con el nombre de distribución posterior. Nótese que el denominador no depende del vector de parámetros y considerando a los datos observados como fijos, corresponde a una constante y puede ser obviada. Por lo tanto, otra representación de la regla de Bayes está dada por \\[ p(\\boldsymbol{\\theta} \\mid \\mathbf{Y})\\propto p(\\mathbf{Y} \\mid \\boldsymbol{\\theta})p(\\boldsymbol{\\theta}) \\] "],["inferencia-bayesiana..html", "5.2 Inferencia Bayesiana.", " 5.2 Inferencia Bayesiana. En términos de estimación, inferencia y predicción, el enfoque Bayesiano supone dos momentos o etapas: Antes de la recolección de las datos, en donde el investigador propone, basado en su conocimiento, experiencia o fuentes externas, una distribución de probabilidad previa para el parámetro de interés. Después de la recolección de los datos. Siguiendo el teorema de Bayes, el investigador actualiza su conocimiento acerca del comportamiento probabilístico del parámetro de interés mediante la distribución posterior de este. "],["modelos-uniparamétricos.html", "5.3 Modelos uniparamétricos", " 5.3 Modelos uniparamétricos Los modelos que están definidos en términos de un solo parámetro que pertenece al conjunto de los números reales se definen como modelos uniparamétricos. "],["modelo-bernoulli.html", "5.4 Modelo Bernoulli", " 5.4 Modelo Bernoulli Suponga que \\(Y\\) es una variable aleatoria con distribución Bernoulli dada por: \\[ p(Y \\mid \\theta)=\\theta^y(1-\\theta)^{1-y}I_{\\{0,1\\}}(y) \\] Como el parámetro \\(\\theta\\) está restringido al espacio \\(\\Theta=[0,1]\\), entonces es posible formular varias opciones para la distribución previa del parámetro. En particular, la distribución uniforme restringida al intervalo \\([0,1]\\) o la distribución Beta parecen ser buenas opciones. Puesto que la distribución uniforme es un caso particular de la distribución Beta. Por lo tanto la distribución previa del parámetro \\(\\theta\\) estará dada por \\[ \\begin{equation} p(\\theta \\mid \\alpha,\\beta)= \\frac{1}{Beta(\\alpha,\\beta)}\\theta^{\\alpha-1}(1-\\theta)^{\\beta-1}I_{[0,1]}(\\theta). \\end{equation} \\] y la distribución posterior del parámetro \\(\\theta\\) sigue una distribución \\[ \\begin{equation*} \\theta \\mid Y \\sim Beta(y+\\alpha,\\beta-y+1) \\end{equation*} \\] Cuando se tiene una muestra aleatoria \\(Y_1,\\ldots,Y_n\\) de variables con distribución Bernoulli de parámetro \\(\\theta\\), entonces la distribución posterior del parámetro de interés es \\[ \\begin{equation*} \\theta \\mid Y_1,\\ldots,Y_n \\sim Beta\\left(\\sum_{i=1}^ny_i+\\alpha,\\beta-\\sum_{i=1}^ny_i+n\\right) \\end{equation*} \\] 5.4.1 Práctica en R library(tidyverse) encuesta &lt;- readRDS(&quot;Recursos/Día1/Sesion4/Data/encuestaCOL18N1.rds&quot;) Sea \\(Y\\) la variable aleatoria \\[ Y_{i}=\\begin{cases} 1 &amp; ingreso&lt;lp\\\\ 0 &amp; ingreso\\geq lp \\end{cases} \\] El tamaño de la muestra es de 19877 Indígena datay &lt;- encuesta %&gt;% filter(etnia_ee == 1) %&gt;% transmute(y = ifelse(ingcorte &lt; lp, 1,0)) addmargins(table(datay$y)) 0 1 Sum 9579 10298 19877 Un grupo de estadístico experto decide utilizar una distribución previa Beta, definiendo los parámetros de la distribución previa como \\(Beta(\\alpha=1, \\beta=1)\\). La distribución posterior del parámetro de interés, que representa la probabilidad de estar por debajo de la linea de pobreza, es \\(Beta(1.0298\\times 10^{4} + 1, 1 - 1.0298\\times 10^{4} + 19877)=Beta(1.0299\\times 10^{4}, 9580)\\) Figura 5.1: Distribución previa (línea roja) y distribución posterior (línea negra) La estimación del parámetro estaría dado por: \\[ E(X) = \\frac{\\alpha}{\\alpha + \\beta} = \\frac{1.0299\\times 10^{4}}{1.0299\\times 10^{4}+ 9580} = 0.5180844 \\] luego, el intervalo de credibilidad para la distribución posterior es. n = length(datay$y) n1 = sum(datay$y) qbeta(c(0.025, 0.975), shape1 = 1 + n1, shape2 = 1 - n1 + n) ## [1] 0.5111369 0.5250285 5.4.2 Práctica en STAN En STAN es posible obtener el mismo tipo de inferencia creando cuatro cadenas cuya distribución de probabilidad coincide con la distribución posterior del ejemplo. ## Definir el modelo data { // Entrada el modelo int&lt;lower=0&gt; n; // Numero de observaciones int y[n]; // Vector de longitud n real a; real b; } parameters { // Definir parámetro real&lt;lower=0, upper=1&gt; theta; } model { // Definir modelo y ~ bernoulli(theta); theta ~ beta(a, b); // Distribución previa } generated quantities { real ypred[n]; // vector de longitud n for (ii in 1:n){ ypred[ii] = bernoulli_rng(theta); } } Para compilar STAN debemos definir los parámetros de entrada sample_data &lt;- list(n = nrow(datay), y = datay$y, a = 1, b = 1) Para ejecutar STAN en R tenemos la librería cmdstanr library(cmdstanr) library(rstan) # file.edit(&quot;Recursos/Día1/Sesion4/Data/modelosStan/1Bernoulli.stan&quot;) # Bernoulli &lt;- cmdstan_model(stan_file = &quot;Recursos/Día1/Sesion4/Data/modelosStan/1Bernoulli.stan&quot;) Bernoulli &lt;- &quot;Recursos/Día1/Sesion4/Data/modelosStan/1Bernoulli.stan&quot; # model_Bernoulli &lt;- Bernoulli$sample(data = sample_data, # chains = 4, # parallel_chains = 4, # seed = 1234, # refresh = 1000) options(mc.cores = parallel::detectCores()) model_Bernoulli &lt;- stan( file = Bernoulli, # Stan program data = sample_data, # named list of data verbose = FALSE, warmup = 500, # number of warmup iterations per chain iter = 1000, # total number of iterations per chain cores = 4, # number of cores (could use one per chain) ) La estimación del parámetro \\(\\theta\\) es: # model_Bernoulli$summary(variables = &quot;theta&quot;) %&gt;% # select(variable:q95) %&gt;% tba() summary(model_Bernoulli, pars = &quot;theta&quot;)$summary %&gt;% tba() mean se_mean sd 2.5% 25% 50% 75% 97.5% n_eff Rhat theta 0.5182 1e-04 0.0034 0.5115 0.516 0.5182 0.5206 0.5243 740.5358 1.0028 Para observar las cadenas compilamos las lineas de código library(posterior) library(ggplot2) #temp &lt;- as_draws_df(model_Bernoulli$draws(variables = &quot;theta&quot;)) temp &lt;- as_draws_df(as.array(model_Bernoulli,pars = &quot;theta&quot;)) ggplot(data = temp, aes(x = theta))+ geom_density(color = &quot;blue&quot;, size = 2) + stat_function(fun = posterior1, args = list(y = datay$y), size = 2) + theme_bw(base_size = 20) + labs(x = latex2exp::TeX(&quot;\\\\theta&quot;), y = latex2exp::TeX(&quot;f(\\\\theta)&quot;)) Figura 5.2: Resultado con STAN (línea azul) y posterior teórica (línea negra) Para validar las cadenas library(bayesplot) # (mcmc_dens_chains(model_Bernoulli$draws(&quot;theta&quot;)) + # mcmc_areas(model_Bernoulli$draws(&quot;theta&quot;)))/ # mcmc_trace(model_Bernoulli$draws(&quot;theta&quot;)) posterior_theta &lt;- as.array(model_Bernoulli, pars = &quot;theta&quot;) (mcmc_dens_chains(posterior_theta) + mcmc_areas(posterior_theta) ) / mcmc_trace(posterior_theta) Predicción de \\(Y\\) en cada una de las iteraciones de las cadenas. # y_pred_B &lt;- model_Bernoulli$draws(variables = &quot;ypred&quot;, format = &quot;matrix&quot;) y_pred_B &lt;- as.array(model_Bernoulli, pars = &quot;ypred&quot;) %&gt;% as_draws_matrix() rowsrandom &lt;- sample(nrow(y_pred_B), 100) y_pred2 &lt;- y_pred_B[rowsrandom, 1:n] ppc_dens_overlay(y = datay$y, y_pred2) "],["modelo-binomial.html", "5.5 Modelo Binomial", " 5.5 Modelo Binomial Cuando se dispone de una muestra aleatoria de variables con distribución Bernoulli \\(Y_1,\\ldots,Y_n\\), la inferencia Bayesiana se puede llevar a cabo usando la distribución Binomial, puesto que es bien sabido que la suma de variables aleatorias Bernoulli \\[ \\begin{equation*} S=\\sum_{i=1}^nY_i \\end{equation*} \\] sigue una distribución Binomial. Es decir: \\[ \\begin{equation} p(S \\mid \\theta)=\\binom{n}{s}\\theta^s(1-\\theta)^{n-s}I_{\\{0,1,\\ldots,n\\}}(s), \\end{equation} \\] Nótese que la distribución Binomial es un caso general para la distribución Bernoulli, cuando \\(n=1\\). Por lo tanto es natural suponer que distribución previa del parámetro \\(\\theta\\) estará dada por \\[ \\begin{equation} p(\\theta \\mid \\alpha,\\beta)= \\frac{1}{Beta(\\alpha,\\beta)}\\theta^{\\alpha-1}(1-\\theta)^{\\beta-1}I_{[0,1]}(\\theta). \\end{equation} \\] La distribución posterior del parámetro \\(\\theta\\) sigue una distribución \\[ \\begin{equation*} \\theta \\mid S \\sim Beta(s+\\alpha,\\beta-s+n) \\end{equation*} \\] Ahora, cuando se tiene una sucesión de variables aleatorias \\(S_1,\\ldots,S_i, \\ldots,S_k\\) independientes y con distribución \\(Binomial(n_i,\\theta_i)\\) para \\(i=1,\\ldots,k\\), entonces la distribución posterior del parámetro de interés \\(\\theta_i\\) es \\[ \\begin{equation*} \\theta_i \\mid s_i \\sim Beta\\left(s_i+\\alpha,\\ \\beta+ n_i- s_i\\right) \\end{equation*} \\] 5.5.1 Práctica en STAN Sea \\(S_k\\) el conteo de personas en condición de pobreza en el \\(k-ésimo\\) departamento en la muestra. dataS &lt;- encuesta %&gt;% transmute( dam = dam_ee, y = ifelse(ingcorte &lt; lp, 1,0) ) %&gt;% group_by(dam) %&gt;% summarise(nd = n(), #Número de ensayos Sd = sum(y) #Número de éxito ) tba(dataS) dam nd Sd 05 45467 7301 08 44321 10297 11 32213 4128 13 35610 10560 15 26485 5717 17 30764 4524 18 28842 11134 19 34357 12348 20 32454 12203 23 31986 10528 25 9068 1516 27 26828 12934 41 30728 8188 44 35618 16412 47 37634 13500 50 29317 6653 52 28927 8949 54 31384 12663 63 28276 6195 66 29199 4664 68 31778 5127 70 35525 11881 73 28416 6295 76 37556 7073 Creando código de STAN data { int&lt;lower=0&gt; K; // Número de provincia int&lt;lower=0&gt; n[K]; // Número de ensayos int&lt;lower=0&gt; s[K]; // Número de éxitos real a; real b; } parameters { real&lt;lower=0, upper=1&gt; theta[K]; // theta_d|s_d } model { for(kk in 1:K) { s[kk] ~ binomial(n[kk], theta[kk]); } to_vector(theta) ~ beta(a, b); } generated quantities { real spred[K]; // vector de longitud K for(kk in 1:K){ spred[kk] = binomial_rng(n[kk],theta[kk]); } } Preparando el código de STAN ## Definir el modelo # file.edit(&quot;Recursos/Día1/Sesion4/Data/modelosStan/3Binomial.stan&quot;) # Binomial2 &lt;- cmdstan_model(stan_file = &quot;Recursos/Día1/Sesion4/Data/modelosStan/3Binomial.stan&quot;) Binomial2 &lt;- &quot;Recursos/Día1/Sesion4/Data/modelosStan/3Binomial.stan&quot; Organizando datos para STAN sample_data &lt;- list(K = nrow(dataS), s = dataS$Sd, n = dataS$nd, a = 1, b = 1) Para ejecutar STAN en R tenemos la librería cmdstanr # model_Binomial2 &lt;- Binomial2$sample(data = sample_data, # chains = 4, # parallel_chains = 4, # seed = 1234, # refresh = 1000) options(mc.cores = parallel::detectCores()) model_Binomial2 &lt;- stan( file = Binomial2, # Stan program data = sample_data, # named list of data verbose = FALSE, warmup = 500, # number of warmup iterations per chain iter = 1000, # total number of iterations per chain cores = 4, # number of cores (could use one per chain) ) La estimación del parámetro \\(\\theta\\) es: # model_Binomial2$summary(variables = &quot;theta&quot;) %&gt;% # select(variable:q95) %&gt;% tba() summary(model_Binomial2, pars = &quot;theta&quot;)$summary %&gt;% tba() mean se_mean sd 2.5% 25% 50% 75% 97.5% n_eff Rhat theta[1] 0.1606 0e+00 0.0018 0.1572 0.1593 0.1606 0.1618 0.1641 4995.662 0.9987 theta[2] 0.2323 0e+00 0.0020 0.2285 0.2309 0.2323 0.2338 0.2362 5068.657 0.9991 theta[3] 0.1281 0e+00 0.0019 0.1246 0.1269 0.1281 0.1294 0.1318 4302.302 0.9989 theta[4] 0.2965 0e+00 0.0023 0.2920 0.2949 0.2965 0.2981 0.3009 5872.753 0.9982 theta[5] 0.2159 0e+00 0.0026 0.2109 0.2141 0.2158 0.2176 0.2210 4494.272 0.9993 theta[6] 0.1471 0e+00 0.0019 0.1433 0.1458 0.1471 0.1484 0.1509 6398.598 0.9992 theta[7] 0.3861 0e+00 0.0028 0.3807 0.3842 0.3861 0.3880 0.3914 5415.280 0.9986 theta[8] 0.3594 0e+00 0.0025 0.3547 0.3577 0.3594 0.3612 0.3642 4735.259 0.9985 theta[9] 0.3760 0e+00 0.0027 0.3708 0.3741 0.3760 0.3779 0.3814 4213.212 0.9986 theta[10] 0.3292 0e+00 0.0025 0.3243 0.3275 0.3292 0.3308 0.3341 5643.390 0.9989 theta[11] 0.1673 1e-04 0.0039 0.1600 0.1647 0.1673 0.1699 0.1751 4524.756 0.9998 theta[12] 0.4821 0e+00 0.0030 0.4760 0.4802 0.4820 0.4841 0.4883 6602.060 0.9987 theta[13] 0.2665 0e+00 0.0025 0.2615 0.2647 0.2665 0.2683 0.2715 6158.453 0.9989 theta[14] 0.4608 0e+00 0.0027 0.4555 0.4590 0.4608 0.4626 0.4661 5894.068 0.9983 theta[15] 0.3587 0e+00 0.0025 0.3539 0.3570 0.3587 0.3605 0.3637 5052.024 0.9988 theta[16] 0.2270 0e+00 0.0025 0.2221 0.2253 0.2271 0.2287 0.2317 4553.205 0.9985 theta[17] 0.3094 0e+00 0.0028 0.3040 0.3075 0.3093 0.3113 0.3148 5761.156 0.9983 theta[18] 0.4035 0e+00 0.0028 0.3978 0.4015 0.4035 0.4055 0.4091 4766.386 0.9999 theta[19] 0.2191 0e+00 0.0024 0.2144 0.2174 0.2190 0.2207 0.2240 5580.557 0.9987 theta[20] 0.1597 0e+00 0.0022 0.1553 0.1583 0.1598 0.1612 0.1640 4125.715 0.9988 theta[21] 0.1614 0e+00 0.0020 0.1574 0.1601 0.1614 0.1627 0.1653 5438.808 0.9990 theta[22] 0.3345 0e+00 0.0024 0.3297 0.3329 0.3344 0.3361 0.3395 4989.644 0.9994 theta[23] 0.2216 0e+00 0.0024 0.2168 0.2200 0.2216 0.2232 0.2263 4874.975 0.9993 theta[24] 0.1883 0e+00 0.0020 0.1844 0.1870 0.1883 0.1896 0.1922 4294.990 0.9984 Para validar las cadenas # mcmc_areas(model_Binomial2$draws(&quot;theta&quot;)) mcmc_areas(as.array(model_Binomial2, pars = &quot;theta&quot;)) # mcmc_trace(model_Binomial2$draws(&quot;theta&quot;)) mcmc_trace(as.array(model_Binomial2, pars = &quot;theta&quot;)) # y_pred_B &lt;- model_Binomial2$draws(variables = &quot;spred&quot;, format = &quot;matrix&quot;) y_pred_B &lt;- as.array(model_Binomial2, pars = &quot;spred&quot;) %&gt;% as_draws_matrix() rowsrandom &lt;- sample(nrow(y_pred_B), 200) y_pred2 &lt;- y_pred_B[rowsrandom, ] g1 &lt;- ggplot(data = dataS, aes(x = Sd))+ geom_histogram(aes(y = ..density..)) + geom_density(size = 2, color = &quot;blue&quot;) + labs(y = &quot;&quot;)+ theme_bw(20) g2 &lt;- ppc_dens_overlay(y = dataS$Sd, y_pred2) g1/g2 "],["modelo-normal-con-media-desconocida.html", "5.6 Modelo Normal con media desconocida", " 5.6 Modelo Normal con media desconocida Suponga que \\(Y_1,\\cdots,Y_n\\) son variables independientes e idénticamente distribuidos con distribución \\(Normal(\\theta,\\sigma^2)\\) con \\(\\theta\\) desconocido pero \\(\\sigma^2\\) conocido. De esta forma, la función de verosimilitud de los datos está dada por \\[ \\begin{align*} p(\\mathbf{Y} \\mid \\theta) &amp;=\\prod_{i=1}^n\\frac{1}{\\sqrt{2\\pi\\sigma^2}}\\exp\\left\\{-\\frac{1}{2\\sigma^2}(y_i-\\theta)^2\\right\\}I_\\mathbb{R}(y) \\\\ &amp;=(2\\pi\\sigma^2)^{-n/2}\\exp\\left\\{-\\frac{1}{2\\sigma^2}\\sum_{i=1}^n(y_i-\\theta)^2\\right\\} \\end{align*} \\] Como el parámetro \\(\\theta\\) puede tomar cualquier valor en los reales, es posible asignarle una distribución previa \\(\\theta \\sim Normal(\\mu,\\tau^2)\\). Bajo este marco de referencia se tienen los siguientes resultados La distribución posterior del parámetro de interés \\(\\theta\\) sigue una distribución \\[ \\begin{equation*} \\theta|\\mathbf{Y} \\sim Normal(\\mu_n,\\tau^2_n) \\end{equation*} \\] En donde \\[ \\begin{equation} \\mu_n=\\frac{\\frac{n}{\\sigma^2}\\bar{Y}+\\frac{1}{\\tau^2}\\mu}{\\frac{n}{\\sigma^2}+\\frac{1}{\\tau^2}} \\ \\ \\ \\ \\ \\ \\ \\text{y} \\ \\ \\ \\ \\ \\ \\ \\tau_n^2=\\left(\\frac{n}{\\sigma^2}+\\frac{1}{\\tau^2}\\right)^{-1} \\end{equation} \\] 5.6.1 Práctica en STAN Sea \\(Y\\) el logaritmo del ingreso dataNormal &lt;- encuesta %&gt;% transmute( dam_ee , logIngreso = log(ingcorte +1)) %&gt;% filter(dam_ee == &quot;08&quot;) #3 media &lt;- mean(dataNormal$logIngreso) Sd &lt;- sd(dataNormal$logIngreso) g1 &lt;- ggplot(dataNormal,aes(x = logIngreso))+ geom_density(size =2, color = &quot;blue&quot;) + stat_function(fun =dnorm, args = list(mean = media, sd = Sd), size =2) + theme_bw(base_size = 20) + labs(y = &quot;&quot;, x = (&quot;Log(Ingreso)&quot;)) g2 &lt;- ggplot(dataNormal, aes(sample = logIngreso)) + stat_qq() + stat_qq_line() + theme_bw(base_size = 20) g1|g2 Figura 5.3: Resultado en la muestra (línea azul) y distribución teórica (línea negra) Creando código de STAN data { int&lt;lower=0&gt; n; // Número de observaciones real y[n]; // LogIngreso real &lt;lower=0&gt; Sigma; // Desviación estándar } parameters { real theta; } model { y ~ normal(theta, Sigma); theta ~ normal(0, 1000); // Distribución previa } generated quantities { real ypred[n]; // Vector de longitud n for(kk in 1:n){ ypred[kk] = normal_rng(theta,Sigma); } } Preparando el código de STAN # file.edit(&quot;Recursos/Día1/Sesion4/Data/modelosStan/4NormalMedia.stan&quot;) # NormalMedia &lt;- cmdstan_model(stan_file = &quot;Recursos/Día1/Sesion4/Data/modelosStan/4NormalMedia.stan&quot;) NormalMedia &lt;- &quot;Recursos/Día1/Sesion4/Data/modelosStan/4NormalMedia.stan&quot; Organizando datos para STAN sample_data &lt;- list(n = nrow(dataNormal), Sigma = sd(dataNormal$logIngreso), y = dataNormal$logIngreso) Para ejecutar STAN en R tenemos la librería cmdstanr # model_NormalMedia &lt;- NormalMedia$sample(data = sample_data, # chains = 4, # parallel_chains = 4, # seed = 1234, # refresh = 1000 # ) options(mc.cores = parallel::detectCores()) model_NormalMedia &lt;- stan( file = NormalMedia, data = sample_data, verbose = FALSE, warmup = 500, iter = 1000, cores = 4 ) La estimación del parámetro \\(\\theta\\) es: # model_NormalMedia$summary(variables = &quot;theta&quot;)%&gt;% # select(variable:q95) %&gt;% tba() summary(model_NormalMedia, pars = &quot;theta&quot;)$summary %&gt;% tba() mean se_mean sd 2.5% 25% 50% 75% 97.5% n_eff Rhat theta 13.1148 1e-04 0.0039 13.1071 13.1122 13.1147 13.1175 13.1224 694.8215 1.0002 # (mcmc_dens_chains(model_NormalMedia$draws(&quot;theta&quot;)) + # mcmc_areas(model_NormalMedia$draws(&quot;theta&quot;)))/ # mcmc_trace(model_NormalMedia$draws(&quot;theta&quot;)) posterior_theta &lt;- as.array(model_NormalMedia, pars = &quot;theta&quot;) (mcmc_dens_chains(posterior_theta) + mcmc_areas(posterior_theta) ) / mcmc_trace(posterior_theta) # y_pred_B &lt;- model_NormalMedia$draws(variables = &quot;ypred&quot;, format = &quot;matrix&quot;) y_pred_B &lt;- as.array(model_NormalMedia, pars = &quot;ypred&quot;) %&gt;% as_draws_matrix() rowsrandom &lt;- sample(nrow(y_pred_B), 100) y_pred2 &lt;- y_pred_B[rowsrandom, ] ppc_dens_overlay(y = as.numeric(dataNormal$logIngreso), y_pred2)/ ppc_dens_overlay(y = exp(as.numeric(dataNormal$logIngreso))-1, exp(y_pred2)-1) + xlim(0,5000000) "],["modelos-multiparamétricos.html", "Capítulo 6 Modelos multiparamétricos", " Capítulo 6 Modelos multiparamétricos La distribución normal univariada que tiene dos parámetros: la media \\(\\theta\\) y la varianza \\(\\sigma^2\\). La distribución multinomial cuyo parámetro es un vector de probabilidades \\(\\boldsymbol{\\theta}\\). "],["modelo-normal-con-media-y-varianza-desconocida.html", "6.1 Modelo Normal con media y varianza desconocida", " 6.1 Modelo Normal con media y varianza desconocida Supongamos que se dispone de realizaciones de un conjunto de variables independientes e idénticamente distribuidas \\(Y_1,\\cdots,Y_n\\sim N(\\theta,\\sigma^2)\\). Cuando se desconoce tanto la media como la varianza de la distribución es necesario plantear diversos enfoques y situarse en el más conveniente, según el contexto del problema. En términos de la asignación de las distribuciones previas para \\(\\theta\\) y \\(\\sigma^2\\) es posible: Suponer que la distribución previa \\(p(\\theta)\\) es independiente de la distribución previa \\(p(\\sigma^2)\\) y que ambas distribuciones son informativas. Suponer que la distribución previa \\(p(\\theta)\\) es independiente de la distribución previa \\(p(\\sigma^2)\\) y que ambas distribuciones son no informativas. Suponer que la distribución previa para \\(\\theta\\) depende de \\(\\sigma^2\\) y escribirla como \\(p(\\theta \\mid \\sigma^2)\\), mientras que la distribución previa de \\(\\sigma^2\\) no depende de \\(\\theta\\) y se puede escribir como \\(p(\\sigma^2)\\). "],["parámetros-independientes.html", "6.2 Parámetros independientes", " 6.2 Parámetros independientes La distribución previa para el parámetro \\(\\theta\\) será \\[ \\begin{equation*} \\theta \\sim Normal(\\mu,\\tau^2) \\end{equation*} \\] Y la distribución previa para el parámetro \\(\\sigma^2\\) será \\[ \\begin{equation*} \\sigma^2 \\sim Inversa-Gamma(n_0/2,n_0\\sigma^2_0/2) \\end{equation*} \\] Asumiendo independencia previa, la distribución previa conjunta estará dada por \\[ \\begin{equation} p(\\theta,\\sigma^2)\\propto (\\sigma^2)^{-n_0/2-1}\\exp\\left\\{-\\dfrac{n_0\\sigma^2_0}{2\\sigma^2}\\right\\} \\exp\\left\\{-\\frac{1}{2\\tau^2}(\\theta-\\mu)^2\\right\\} \\end{equation} \\] La distribución posterior conjunta de los parámetros de interés está dada por \\[ \\begin{align} p(\\theta,\\sigma^2 \\mid \\mathbf{Y})&amp;\\propto (\\sigma^2)^{-(n+n_0)/2-1} \\notag \\\\ &amp;\\times \\exp\\left\\{-\\frac{1}{2\\sigma^2}\\left[n_0\\sigma^2_0+(n-1)S^2+n(\\bar{y}-\\theta)^2\\right]-\\frac{1}{2\\tau^2}(\\theta-\\mu)^2\\right\\} \\end{align} \\] La distribución posterior condicional de \\(\\theta\\) es \\[ \\begin{equation} \\theta \\mid \\sigma^2,\\mathbf{Y} \\sim Normal(\\mu_n,\\tau_n^2) \\end{equation} \\] En donde las expresiones para \\(\\mu_n\\) y \\(\\tau_n^2\\) están dados previamente. Por otro lado, la distribución posterior condicional de \\(\\sigma^2\\) es \\[ \\begin{equation} \\sigma^2 \\mid \\theta,\\mathbf{Y} \\sim Inversa-Gamma\\left(\\dfrac{n_0+n}{2},\\dfrac{v_0}{2}\\right) \\end{equation} \\] con \\(v_0=n_0\\sigma^2_0+(n-1)S^2+n(\\bar{y}-\\theta)^2\\). 6.2.1 Práctica en STAN Sea \\(Y\\) el logaritmo del ingreso dataNormal &lt;- encuesta %&gt;% transmute(dam_ee, logIngreso = log(ingcorte +1)) %&gt;% filter(dam_ee == &quot;08&quot;) Creando código de STAN data { int&lt;lower=0&gt; n; real y[n]; } parameters { real sigma; real theta; } transformed parameters { real sigma2; sigma2 = pow(sigma, 2); } model { y ~ normal(theta, sigma); theta ~ normal(0, 1000); sigma2 ~ inv_gamma(0.001, 0.001); } generated quantities { real ypred[n]; // vector de longitud n for(kk in 1:n){ ypred[kk] = normal_rng(theta,sigma); } } Preparando el código de STAN # file.edit(&quot;Recursos/Día1/Sesion4/Data/modelosStan/5NormalMeanVar.stan&quot;) # NormalMeanVar &lt;- cmdstan_model(stan_file = &quot;Recursos/Día1/Sesion4/Data/modelosStan/5NormalMeanVar.stan&quot;) NormalMeanVar &lt;- &quot;Recursos/Día1/Sesion4/Data/modelosStan/5NormalMeanVar.stan&quot; Organizando datos para STAN sample_data &lt;- list(n = nrow(dataNormal), y = dataNormal$logIngreso) Para ejecutar STAN en R tenemos la librería cmdstanr # model_NormalMedia &lt;- NormalMeanVar$sample(data = sample_data, # chains = 4, # parallel_chains = 4, # seed = 1234, # refresh = 1000) options(mc.cores = parallel::detectCores()) model_NormalMedia &lt;- stan( file = NormalMeanVar, data = sample_data, verbose = FALSE, warmup = 500, iter = 1000, cores = 4 ) La estimación del parámetro \\(\\theta\\) y \\(\\sigma^2\\) es: # model_NormalMedia$summary(variables = c(&quot;theta&quot;, &quot;sigma2&quot;, &quot;sigma&quot;)) %&gt;% # select(variable:q95) %&gt;% tba() summary(model_NormalMedia, pars = c(&quot;theta&quot;, &quot;sigma2&quot;, &quot;sigma&quot;))$summary %&gt;% tba() mean se_mean sd 2.5% 25% 50% 75% 97.5% n_eff Rhat theta 13.1147 1e-04 0.0041 13.1067 13.1119 13.1148 13.1175 13.1226 1127.412 1.0010 sigma2 0.6987 1e-04 0.0046 0.6898 0.6955 0.6987 0.7016 0.7078 1612.814 1.0017 sigma 0.8359 1e-04 0.0028 0.8305 0.8340 0.8359 0.8376 0.8413 1613.833 1.0017 # (mcmc_dens_chains(model_NormalMedia$draws(&quot;theta&quot;)) + # mcmc_areas(model_NormalMedia$draws(&quot;theta&quot;)))/ # mcmc_trace(model_NormalMedia$draws(&quot;theta&quot;)) posterior_theta &lt;- as.array(model_NormalMedia, pars = &quot;theta&quot;) (mcmc_dens_chains(posterior_theta) + mcmc_areas(posterior_theta) ) / mcmc_trace(posterior_theta) # (mcmc_dens_chains(model_NormalMedia$draws(&quot;sigma2&quot;)) + # mcmc_areas(model_NormalMedia$draws(&quot;sigma2&quot;)))/ # mcmc_trace(model_NormalMedia$draws(&quot;sigma2&quot;)) posterior_sigma2 &lt;- as.array(model_NormalMedia, pars = &quot;sigma2&quot;) (mcmc_dens_chains(posterior_sigma2) + mcmc_areas(posterior_sigma2) ) / mcmc_trace(posterior_sigma2) # (mcmc_dens_chains(model_NormalMedia$draws(&quot;sigma&quot;)) + # mcmc_areas(model_NormalMedia$draws(&quot;sigma&quot;)))/ # mcmc_trace(model_NormalMedia$draws(&quot;sigma&quot;)) posterior_sigma &lt;- as.array(model_NormalMedia, pars = &quot;sigma&quot;) (mcmc_dens_chains(posterior_sigma) + mcmc_areas(posterior_sigma) ) / mcmc_trace(posterior_sigma) # y_pred_B &lt;- model_NormalMedia$draws(variables = &quot;ypred&quot;, # format = &quot;matrix&quot;) y_pred_B &lt;- as.array(model_NormalMedia, pars = &quot;ypred&quot;) %&gt;% as_draws_matrix() rowsrandom &lt;- sample(nrow(y_pred_B), 100) y_pred2 &lt;- y_pred_B[rowsrandom, ] ppc_dens_overlay(y = as.numeric(exp(dataNormal$logIngreso)-1), y_pred2) + xlim(0,5000000) "],["modelo-multinomial.html", "6.3 Modelo Multinomial", " 6.3 Modelo Multinomial En esta sección discutimos el modelamiento bayesiano de datos provenientes de una distribución multinomial que corresponde a una extensión multivariada de la distribución binomial. Suponga que \\(\\textbf{Y}=(Y_1,\\ldots,Y_p)&#39;\\) es un vector aleatorio con distribución multinomial, así, su distribución está parametrizada por el vector \\(\\boldsymbol{\\theta}=(\\theta_1,\\ldots,\\theta_p)&#39;\\) y está dada por la siguiente expresión \\[ \\begin{equation} p(\\mathbf{Y} \\mid \\boldsymbol{\\theta})=\\binom{n}{y_1,\\ldots,y_p}\\prod_{i=1}^p\\theta_i^{y_i} \\ \\ \\ \\ \\ \\theta_i&gt;0 \\texttt{ , } \\sum_{i=1}^py_i=n \\texttt{ y } \\sum_{i=1}^p\\theta_i=1 \\end{equation} \\] Donde \\[ \\begin{equation*} \\binom{n}{y_1,\\ldots,y_p}=\\frac{n!}{y_1!\\cdots y_p!}. \\end{equation*} \\] Como cada parámetro \\(\\theta_i\\) está restringido al espacio \\(\\Theta=[0,1]\\), entonces es posible asignar a la distribución de Dirichlet como la distribución previa del vector de parámetros. Por lo tanto la distribución previa del vector de parámetros \\(\\boldsymbol{\\theta}\\), parametrizada por el vector de hiperparámetros \\(\\boldsymbol{\\alpha}=(\\alpha_1,\\ldots,\\alpha_p)&#39;\\), está dada por \\[ \\begin{equation} p(\\boldsymbol{\\theta} \\mid \\boldsymbol{\\alpha})=\\frac{\\Gamma(\\alpha_1+\\cdots+\\alpha_p)}{\\Gamma(\\alpha_1)\\cdots\\Gamma(\\alpha_p)} \\prod_{i=1}^p\\theta_i^{\\alpha_i-1} \\ \\ \\ \\ \\ \\alpha_i&gt;0 \\texttt{ y } \\sum_{i=1}^p\\theta_i=1 \\end{equation} \\] La distribución posterior del parámetro \\(\\boldsymbol{\\theta}\\) sigue una distribución \\(Dirichlet(y_1+\\alpha_1,\\ldots,y_p+\\alpha_p)\\) 6.3.1 Práctica en STAN Sea \\(Y\\) condición de actividad laboral dataMult &lt;- encuesta %&gt;% filter(condact3 %in% 1:3) %&gt;% transmute( empleo = as_factor(condact3)) %&gt;% group_by(empleo) %&gt;% tally() %&gt;% mutate(theta = n/sum(n)) tba(dataMult) empleo n theta 1 348015 0.5537 2 42045 0.0669 3 238426 0.3794 donde 1 corresponde a Ocupado, 2 son los Desocupado y 3 son Inactivo Creando código de STAN data { int&lt;lower=0&gt; k; // Número de cátegoria int y[k]; // Número de exitos vector[k] alpha; // Parámetro de las distribción previa } parameters { simplex[k] theta; } transformed parameters { real delta; // Tasa de desocupación delta = theta[2]/ (theta[2] + theta[1]); // (Desocupado)/(Desocupado + Ocupado) } model { y ~ multinomial(theta); theta ~ dirichlet(alpha); } generated quantities { int ypred[k]; ypred = multinomial_rng(theta, sum(y)); } Preparando el código de STAN # file.edit(&quot;Recursos/Día1/Sesion4/Data/modelosStan/6Multinom.stan&quot;) # Multinom &lt;- cmdstan_model(stan_file = &quot;Recursos/Día1/Sesion4/Data/modelosStan/6Multinom.stan&quot;) Multinom &lt;- &quot;Recursos/Día1/Sesion4/Data/modelosStan/6Multinom.stan&quot; Organizando datos para STAN sample_data &lt;- list(k = nrow(dataMult), y = dataMult$n, alpha = c(0.5, 0.5, 0.5)) Para ejecutar STAN en R tenemos la librería cmdstanr # model_Multinom &lt;- Multinom$sample(data = sample_data, # chains = 4, # parallel_chains = 4, # seed = 1234, # refresh = 1000) options(mc.cores = parallel::detectCores()) model_Multinom &lt;- stan( file = Multinom, data = sample_data, verbose = FALSE, warmup = 500, iter = 1000, cores = 4 ) La estimación del parámetro \\(\\theta\\) y \\(\\delta\\) es: # model_Multinom$summary(variables = c(&quot;delta&quot;, &quot;theta&quot;))%&gt;% # select(variable:q95) %&gt;% tba() summary(model_Multinom, pars = c(&quot;delta&quot;, &quot;theta&quot;))$summary %&gt;% tba() mean se_mean sd 2.5% 25% 50% 75% 97.5% n_eff Rhat delta 0.1078 0 5e-04 0.1068 0.1075 0.1078 0.1082 0.1088 1097.4077 1.0019 theta[1] 0.5537 0 6e-04 0.5525 0.5533 0.5537 0.5542 0.5549 1978.4575 1.0006 theta[2] 0.0669 0 3e-04 0.0663 0.0667 0.0669 0.0671 0.0675 993.4809 1.0020 theta[3] 0.3794 0 6e-04 0.3782 0.3789 0.3794 0.3798 0.3806 1556.6998 1.0007 # (mcmc_dens_chains(model_Multinom$draws(&quot;theta[1]&quot;)) + # mcmc_areas(model_Multinom$draws(&quot;theta[1]&quot;)))/ # mcmc_trace(model_Multinom$draws(&quot;theta[1]&quot;)) posterior_theta1 &lt;- as.array(model_Multinom, pars = &quot;theta[1]&quot;) (mcmc_dens_chains(posterior_theta1) + mcmc_areas(posterior_theta1) ) / mcmc_trace(posterior_theta1) # (mcmc_dens_chains(model_Multinom$draws(&quot;theta[2]&quot;)) + # mcmc_areas(model_Multinom$draws(&quot;theta[2]&quot;)))/ # mcmc_trace(model_Multinom$draws(&quot;theta[2]&quot;)) posterior_theta2 &lt;- as.array(model_Multinom, pars = &quot;theta[2]&quot;) (mcmc_dens_chains(posterior_theta2) + mcmc_areas(posterior_theta2) ) / mcmc_trace(posterior_theta2) # (mcmc_dens_chains(model_Multinom$draws(&quot;theta[3]&quot;)) + # mcmc_areas(model_Multinom$draws(&quot;theta[3]&quot;)))/ # mcmc_trace(model_Multinom$draws(&quot;theta[3]&quot;)) posterior_theta3 &lt;- as.array(model_Multinom, pars = &quot;theta[3]&quot;) (mcmc_dens_chains(posterior_theta3) + mcmc_areas(posterior_theta3) ) / mcmc_trace(posterior_theta3) # (mcmc_dens_chains(model_Multinom$draws(&quot;delta&quot;)) + # mcmc_areas(model_Multinom$draws(&quot;delta&quot;)))/ # mcmc_trace(model_Multinom$draws(&quot;delta&quot;)) posterior_delta &lt;- as.array(model_Multinom, pars = &quot;delta&quot;) (mcmc_dens_chains(posterior_delta) + mcmc_areas(posterior_delta) ) / mcmc_trace(posterior_delta) n &lt;- nrow(dataMult) # y_pred_B &lt;- model_Multinom$draws(variables = &quot;ypred&quot;, format = &quot;matrix&quot;) y_pred_B &lt;- as.array(model_Multinom, pars = &quot;ypred&quot;) %&gt;% as_draws_matrix() rowsrandom &lt;- sample(nrow(y_pred_B), 100) y_pred2 &lt;- y_pred_B[, 1:n] ppc_dens_overlay(y = as.numeric(dataMult$n), y_pred2) "],["función-generalizada-de-varianza-fgv.html", "Capítulo 7 Función Generalizada de Varianza (FGV)", " Capítulo 7 Función Generalizada de Varianza (FGV) Uno de los insumos más importantes en el modelo de áreas es la varianza del estimador directo, a nivel de dominio, la cual no puede calcularse de ningún modo. En correspondencia, este valor debe estimarse desde los datos recolectados en cada dominio. Sin embargo, en dominios en las que se cuenta con un tamaño de muestra muy pequeño, estas estimaciones no tendrán un buen comportamiento. Por ende, es muy útil utilizar un modelo de suavizamiento de las varianzas para eliminar el ruido y la volatilidad de estas estimaciones y extraer la verdadera señal del proceso Hidiroglou (2019) afirma que \\(E_{mp}\\left(\\hat{\\theta}^{dir}_d\\right)=\\boldsymbol{x}_{d}\\boldsymbol{\\beta}\\) y \\(V_{mp}\\left(\\hat{\\theta}^{dir}_d\\right)=\\sigma_{u}^2+\\tilde{\\psi}^2_{d}\\), en donde el subíndice \\(mp\\) hace referencia a la inferencia doble que se debe tener en cuenta en este tipo de ajustes y define la medida de probabilidad conjunta entre el modelo y el diseño de muestreo. \\(m\\) hace referencia a la medida de probabilidad inducida por el modelamiento y la inclusión de las covariables auxiliares (\\(\\boldsymbol{x}_{d}\\)). \\(p\\) hacer referencia a la medida de probabilidad inducida por el diseño de muestreo complejo que induce las estimaciones directas. La solución que acá se plantea se conoce con el nombre de Función Generalizada de Varianza, la cual consiste en ajustar un modelo log-lineal a la varianza directa estimada. Partiendo del hecho de que se tiene acceso a un estimador insesgado de \\(\\psi^2\\), denotado por \\(\\hat{\\psi}^2\\) se tiene que: \\[ E_{mp}\\left(\\hat{\\psi}_{d}^{2}\\right)=E_{m}\\left(E_{p}\\left(\\psi_{d}^{2}\\right)\\right)=E_{m}\\left(\\psi_{d}^{2}\\right)=\\tilde{\\psi}_{d}^{2} \\] La anterior igualdad puede interpretarse como que un estimador insesgado y simple de \\(\\tilde{\\psi}_{d}^{2}\\) puede ser \\(\\hat{\\psi}_{d}^{2}\\). Sin embargo, este estimador de muestreo es inestable cuando el tamaño de muestra es pequeño, que es justo el paradigma dominante en la estimación de áreas pequeñas. Rivest and Belmonte (2000) consideran modelos de suavizamiento para la estimación de las varianzas directas definidos de la siguiente manera: \\[ \\log\\left(\\hat{\\psi}_{d}^{2}\\right)=\\boldsymbol{z}_{d}^{t}\\boldsymbol{\\alpha}+\\boldsymbol{\\varepsilon}_{d} \\] En donde \\(\\boldsymbol{z}_{d}\\) es un vector de covariables explicativas que son funciones de \\(\\boldsymbol{x}_{d}\\), \\(\\boldsymbol{\\alpha}\\) es un vector de parámetros que deben ser estimados, \\(\\boldsymbol{\\varepsilon}_{d}\\) son errores aleatorios con media cero y varianza constante, que se asumen idénticamente distribuidos condicionalmente sobre \\(\\boldsymbol{z}_{d}\\). Del anterior modelo, la estimación suavizada de la varianza de muestreo está dada por: \\[ \\tilde{\\psi}_{d}^{2}=E_{mp}\\left(\\psi_{d}^{2}\\right)=\\exp\\left(\\boldsymbol{z}_{d}^{t}\\boldsymbol{\\alpha}\\right)\\times\\Delta \\] En donde, \\(E_{mp}\\left(\\varepsilon_{d}\\right)=\\Delta\\). No hay necesidad de especificar una distribución paramétrica para los errores de este modelo. Al utilizar el método de los momentos, se tiene el siguiente estimador insesgado para \\(\\Delta\\): \\[ \\hat{\\Delta}=\\frac{\\sum_{d=1}^{D}\\hat{\\psi}_{d}^{2}}{\\sum_{d=1}^{D}\\exp\\left(\\boldsymbol{z}_{d}^{t}\\boldsymbol{\\alpha}\\right)} \\] De la misma forma, al utilizar los procedimientos estándar en una regresión lineal, la estimación del coeficiente de parámetros de regresión está dada por la siguiente expresión: \\[ \\hat{\\boldsymbol{\\alpha}}=\\left(\\sum_{d=1}^{D}\\boldsymbol{z}_{d}\\boldsymbol{z}_{d}^{t}\\right)^{-1}\\sum_{d=1}^{D}\\boldsymbol{z}_{d}\\log\\left(\\hat{\\psi}_{d}^{2}\\right) \\] Por último, el estimador suavizado de la varianza muestral está definido por: \\[ \\hat{\\tilde{\\psi}}_{d}^{2}=\\exp\\left(\\boldsymbol{z}_{d}^{t}\\hat{\\boldsymbol{\\alpha}}\\right)\\hat{\\Delta} \\] "],["datos-de-la-encuesta.html", "7.1 Datos de la encuesta", " 7.1 Datos de la encuesta library(tidyverse) library(magrittr) source(&quot;Recursos/Día2/Sesion1/0Recursos/0Source_FH.R&quot;) encuesta &lt;- readRDS(&quot;Recursos/Día2/Sesion1/Data/encuestaCOL18N1.rds&quot;) %&gt;% transmute( dam = dam_ee, dam2, wkx = `_fep`, upm = segmento, estrato = paste0(dam, haven::as_factor(area_ee,levels = &quot;values&quot;)), pobreza = ifelse(ingcorte &lt; lp, 1 , 0)) dam: Corresponde al código asignado a la división administrativa mayor del país. dam2: Corresponde al código asignado a la segunda división administrativa del país. lp linea de pobreza definida por CEPAL. Factor de expansión por persona (fep) dam dam2 wkx upm estrato pobreza 05 05360 127.2220 010126005360 051 0 05 05360 127.2220 010126005360 051 0 05 05360 127.2220 010126005360 051 0 05 05360 127.2220 010126005360 051 0 05 05360 127.2220 010126005360 051 0 05 05360 125.7202 010126005360 051 1 05 05360 125.7202 010126005360 051 1 05 05360 125.7202 010126005360 051 1 05 05360 125.7202 010126005360 051 1 05 05360 115.8661 010126005360 051 1 Definir el diseño muestral haciendo uso de las librerías srvyr y survey library(survey) library(srvyr) options(survey.lonely.psu = &quot;adjust&quot;) diseno &lt;- as_survey_design( ids = upm, weights = wkx, strata = estrato, nest = TRUE, .data = encuesta ) summary(diseno) ## Stratified 1 - level Cluster Sampling design (with replacement) ## With (21869) clusters. ## Called via srvyr ## Probabilities: ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 0.001089 0.012313 0.037623 0.057119 0.080947 0.783027 ## Stratum Sizes: ## 051 052 081 082 111 112 131 132 151 152 171 172 ## obs 41761 3706 43299 1022 32177 36 32757 2853 23299 3186 27959 2805 ## design.PSU 1247 123 926 29 972 1 828 83 762 131 905 101 ## actual.PSU 1247 123 926 29 972 1 828 83 762 131 905 101 ## 181 182 191 192 201 202 231 232 251 252 271 272 ## obs 23698 5144 28826 5531 30225 2229 29181 2805 6271 2797 22812 4016 ## design.PSU 760 130 852 180 832 81 650 83 181 106 699 140 ## actual.PSU 760 130 852 180 832 81 650 83 181 106 699 140 ## 411 412 441 442 471 472 501 502 521 522 541 542 ## obs 27446 3282 32062 3556 34690 2944 26381 2936 24656 4271 27554 3830 ## design.PSU 866 105 790 120 889 84 803 96 734 131 793 134 ## actual.PSU 866 105 790 120 889 84 803 96 734 131 793 134 ## 631 632 661 662 681 682 701 702 731 732 761 762 ## obs 26616 1660 25945 3254 28390 3388 32471 3054 25315 3101 35065 2491 ## design.PSU 864 55 818 103 749 108 737 96 788 91 1027 86 ## actual.PSU 864 55 818 103 749 108 737 96 788 91 1027 86 ## Data variables: ## [1] &quot;dam&quot; &quot;dam2&quot; &quot;wkx&quot; &quot;upm&quot; &quot;estrato&quot; &quot;pobreza&quot; Para la estimación directa de la proporción se emplea la función direct.supr, disponible en el archivo 0Source_FH.R, dando como resultado. directodam2 &lt;- direct.supr(design.base = diseno, variable = pobreza, group = dam2, upm = upm, estrato = estrato) directodam2 %&gt;% group_by(Flag) %&gt;% summarise(n = n()) %&gt;% arrange(n) %&gt;% tba() Flag n Excluir 59 Incluir 379 Para los dominios que no son excluidos se hace la transformación arcoseno, calculo del DEFF y varianza base_sae &lt;- directodam2 %&gt;% filter(Flag != &quot;Excluir&quot;) %&gt;% transmute( dam2 = dam2, # Id para los dominios nd = n, # Número de observaciones por dominios n_effec = n.eff, # n efectivo. pobreza = p, # Estimación de la variable pobreza_T = asin(sqrt(pobreza)), # Transformación arcoseno vardir = ee ^ 2, # Estimación de la varianza directa cv = CV, var_zd = 1 / (4 * n_effec), # Varianza para la tranformación arcsin deff_dam2 = deff # Deff por dominio ) # View(base_sae) tba(head(base_sae)) dam2 nd n_effec pobreza pobreza_T vardir cv var_zd deff_dam2 05001 27432 1914.8077 0.1597 0.4111 0.0000 4.1932 0.0001 14.3262 05002 257 21.3006 0.4049 0.6897 0.0032 14.0276 0.0117 12.0654 05031 199 7.8051 0.3817 0.6660 0.0042 17.0554 0.0320 25.4963 05034 223 25.8934 0.4731 0.7585 0.0018 8.8997 0.0097 8.6122 05045 480 5.0044 0.2876 0.5661 0.0064 27.9009 0.0500 95.9148 05079 191 22.5008 0.4001 0.6848 0.0063 19.8514 0.0111 8.4886 Seleccionando las variables de interés para la FGV. baseFGV &lt;- base_sae %&gt;% select(dam2, pobreza, nd, vardir) %&gt;% mutate(ln_sigma2 = log(vardir)) "],["análisis-gráfico.html", "Capítulo 8 Análisis gráfico", " Capítulo 8 Análisis gráfico theme_set(theme_bw()) # pobreza vs Ln_sigma2 # p1 &lt;- ggplot(baseFGV, aes(x = pobreza, y = ln_sigma2)) + geom_point() + geom_smooth(method = &quot;loess&quot;) + xlab(&quot;pobreza&quot;) # Tamaño de muestra vs Ln_sigma2 # p2 &lt;- ggplot(baseFGV, aes(x = nd, y = ln_sigma2)) + geom_point() + geom_smooth(method = &quot;loess&quot;) + xlab(&quot;Tamaño de muestra&quot;) # Número de pobres vs Ln_sigma2 # p3 &lt;- ggplot(baseFGV, aes(x = pobreza * nd, y = ln_sigma2)) + geom_point() + geom_smooth(method = &quot;loess&quot;) + xlab(&quot;Número de pobres&quot;) # Raiz_pobreza vs Ln_sigma2 # p4 &lt;- ggplot(baseFGV, aes(x = sqrt(pobreza), y = ln_sigma2)) + geom_point() + geom_smooth(method = &quot;loess&quot;) + xlab(&quot;Raiz cuadrada de pobreza&quot;) library(patchwork) (p1 | p2) / (p3 | p4) "],["modelo-para-la-varianza.html", "Capítulo 9 Modelo para la varianza", " Capítulo 9 Modelo para la varianza library(gtsummary) FGV1 &lt;- lm(ln_sigma2 ~ pobreza + I(nd^2) + I(sqrt(pobreza)), data = baseFGV) tbl_regression(FGV1) %&gt;% add_glance_table(include = c(r.squared, adj.r.squared)) html { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Helvetica Neue', 'Fira Sans', 'Droid Sans', Arial, sans-serif; } #srxmuctavx .gt_table { display: table; border-collapse: collapse; margin-left: auto; margin-right: auto; color: #333333; font-size: 16px; font-weight: normal; font-style: normal; background-color: #FFFFFF; width: auto; border-top-style: solid; border-top-width: 2px; border-top-color: #A8A8A8; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #A8A8A8; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; } #srxmuctavx .gt_heading { background-color: #FFFFFF; text-align: center; border-bottom-color: #FFFFFF; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #srxmuctavx .gt_caption { padding-top: 4px; padding-bottom: 4px; } #srxmuctavx .gt_title { color: #333333; font-size: 125%; font-weight: initial; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; border-bottom-color: #FFFFFF; border-bottom-width: 0; } #srxmuctavx .gt_subtitle { color: #333333; font-size: 85%; font-weight: initial; padding-top: 0; padding-bottom: 6px; padding-left: 5px; padding-right: 5px; border-top-color: #FFFFFF; border-top-width: 0; } #srxmuctavx .gt_bottom_border { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #srxmuctavx .gt_col_headings { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #srxmuctavx .gt_col_heading { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 6px; padding-left: 5px; padding-right: 5px; overflow-x: hidden; } #srxmuctavx .gt_column_spanner_outer { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; padding-top: 0; padding-bottom: 0; padding-left: 4px; padding-right: 4px; } #srxmuctavx .gt_column_spanner_outer:first-child { padding-left: 0; } #srxmuctavx .gt_column_spanner_outer:last-child { padding-right: 0; } #srxmuctavx .gt_column_spanner { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 5px; overflow-x: hidden; display: inline-block; width: 100%; } #srxmuctavx .gt_group_heading { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; text-align: left; } #srxmuctavx .gt_empty_group_heading { padding: 0.5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: middle; } #srxmuctavx .gt_from_md > :first-child { margin-top: 0; } #srxmuctavx .gt_from_md > :last-child { margin-bottom: 0; } #srxmuctavx .gt_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; margin: 10px; border-top-style: solid; border-top-width: 1px; border-top-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; overflow-x: hidden; } #srxmuctavx .gt_stub { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 5px; padding-right: 5px; } #srxmuctavx .gt_stub_row_group { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 5px; padding-right: 5px; vertical-align: top; } #srxmuctavx .gt_row_group_first td { border-top-width: 2px; } #srxmuctavx .gt_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #srxmuctavx .gt_first_summary_row { border-top-style: solid; border-top-color: #D3D3D3; } #srxmuctavx .gt_first_summary_row.thick { border-top-width: 2px; } #srxmuctavx .gt_last_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #srxmuctavx .gt_grand_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #srxmuctavx .gt_first_grand_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: double; border-top-width: 6px; border-top-color: #D3D3D3; } #srxmuctavx .gt_striped { background-color: rgba(128, 128, 128, 0.05); } #srxmuctavx .gt_table_body { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #srxmuctavx .gt_footnotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #srxmuctavx .gt_footnote { margin: 0px; font-size: 90%; padding-left: 4px; padding-right: 4px; padding-left: 5px; padding-right: 5px; } #srxmuctavx .gt_sourcenotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #srxmuctavx .gt_sourcenote { font-size: 90%; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; } #srxmuctavx .gt_left { text-align: left; } #srxmuctavx .gt_center { text-align: center; } #srxmuctavx .gt_right { text-align: right; font-variant-numeric: tabular-nums; } #srxmuctavx .gt_font_normal { font-weight: normal; } #srxmuctavx .gt_font_bold { font-weight: bold; } #srxmuctavx .gt_font_italic { font-style: italic; } #srxmuctavx .gt_super { font-size: 65%; } #srxmuctavx .gt_footnote_marks { font-style: italic; font-weight: normal; font-size: 75%; vertical-align: 0.4em; } #srxmuctavx .gt_asterisk { font-size: 100%; vertical-align: 0; } #srxmuctavx .gt_indent_1 { text-indent: 5px; } #srxmuctavx .gt_indent_2 { text-indent: 10px; } #srxmuctavx .gt_indent_3 { text-indent: 15px; } #srxmuctavx .gt_indent_4 { text-indent: 20px; } #srxmuctavx .gt_indent_5 { text-indent: 25px; } Characteristic Beta 95% CI1 p-value pobreza -12 -14, -9.5 I(nd^2) 0.00 0.00, 0.00 I(sqrt(pobreza)) 16 14, 19 R² 0.608 Adjusted R² 0.604 1 CI = Confidence Interval Ponderador FGV delta.hat = sum(baseFGV$vardir) / sum(exp(fitted.values(FGV1))) delta.hat ## [1] 1.303171 Varianza suavizada para los dominios observados hat.sigma &lt;- data.frame(dam2 = baseFGV$dam2, hat_var = delta.hat * exp(fitted.values(FGV1))) baseFGV &lt;- left_join(baseFGV, hat.sigma) tba(head(baseFGV, 10)) dam2 pobreza nd vardir ln_sigma2 hat_var 05001 0.1597 27432 0.0000 -10.0123 0.0001 05002 0.4049 257 0.0032 -5.7366 0.0060 05031 0.3817 199 0.0042 -5.4635 0.0058 05034 0.4731 223 0.0018 -6.3351 0.0062 05045 0.2876 480 0.0064 -5.0451 0.0047 05079 0.4001 191 0.0063 -5.0660 0.0060 05088 0.1314 4457 0.0002 -8.5360 0.0016 05093 0.3273 168 0.0063 -5.0724 0.0052 05120 0.7049 180 0.0061 -5.0921 0.0048 05129 0.1140 554 0.0014 -6.5515 0.0014 Validación del modelo para la FGV par(mfrow = c(2, 2)) plot(FGV1) Comparación entre varianza estimada con pronosticada por la FGV ggplot(baseFGV , aes(y = vardir, x = hat_var)) + geom_point() + geom_smooth(method = &quot;loess&quot;) Predicción de la varianza suavizada base_sae &lt;- base_sae %&gt;% left_join(hat.sigma, by = &quot;dam2&quot;) Organizando la información para exportar, realizamos validaciones adicionales sobre el deff base_FH &lt;- base_sae %&gt;% mutate( deff_dam2 = ifelse(is.nan(deff_dam2), 1, deff_dam2), deff_FGV = ifelse( vardir == 0 , 1, hat_var / (vardir / deff_dam2) ), # Criterio MDS para regularizar el DeffFGV deff_FGV = ifelse(deff_FGV &lt; 1, 1, deff_FGV), n_eff_FGV = nd / deff_FGV ) saveRDS(object = base_FH, &quot;Recursos/Día2/Sesion1/Data/base_FH_2018.rds&quot;) "],["análisis-gráfico-1.html", "Capítulo 10 Análisis gráfico", " Capítulo 10 Análisis gráfico ggplot(base_FH %&gt;% arrange(nd), aes(x = hat_var, y = vardir)) + geom_point() + geom_smooth(method = &quot;lm&quot;, col = 2) + labs(x = &quot;FGV&quot;, y = &quot;VarDirEst&quot;) + ylab(&quot;Varianza del Estimador Directo&quot;) "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
